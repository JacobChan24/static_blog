const e=JSON.parse('{"key":"v-6a63085d","path":"/Tech/Front-end/03_VUE/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7.html","title":"","lang":"en-US","frontmatter":{"description":"为什么需要？ 1.在插值表达式中写逻辑很麻烦，且也写不了很复杂的逻辑 2.与方法相比，可以避免多次进行重复的计算，提高程序响应速度且节省性能 怎么用？ 计算属性应该是根据数据属性中的值计算出来的目的属性，依赖响应式。当计算属性的响应式依赖更新的时候，计算属性也会重新计算然后被缓存 不要再计算式属性中做异步请求或者更改DOM！ 我们应该避免在代码里面修改计算属性里面的值，计算属性只读 可以关联多个实时计算的对象，相比起来，侦听器只能侦听一个数据的变化","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/Tech/Front-end/03_VUE/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7.html"}],["meta",{"property":"og:site_name","content":"Blog Demo"}],["meta",{"property":"og:description","content":"为什么需要？ 1.在插值表达式中写逻辑很麻烦，且也写不了很复杂的逻辑 2.与方法相比，可以避免多次进行重复的计算，提高程序响应速度且节省性能 怎么用？ 计算属性应该是根据数据属性中的值计算出来的目的属性，依赖响应式。当计算属性的响应式依赖更新的时候，计算属性也会重新计算然后被缓存 不要再计算式属性中做异步请求或者更改DOM！ 我们应该避免在代码里面修改计算属性里面的值，计算属性只读 可以关联多个实时计算的对象，相比起来，侦听器只能侦听一个数据的变化"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:author","content":"Mr.Jacob"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Jacob\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":0.68,"words":203},"filePathRelative":"Tech/Front-end/03_VUE/计算属性.md","excerpt":"<h4> 为什么需要？</h4>\\n<p>1.在插值表达式中写逻辑很麻烦，且也写不了很复杂的逻辑\\n2.与方法相比，可以避免多次进行重复的计算，提高程序响应速度且节省性能</p>\\n<h4> 怎么用？</h4>\\n<ul>\\n<li>计算属性应该是根据数据属性中的值计算出来的目的属性，依赖响应式。当计算属性的响应式依赖更新的时候，计算属性也会重新计算然后被缓存</li>\\n<li>不要再计算式属性中做异步请求或者更改DOM！</li>\\n<li>我们应该避免在代码里面修改计算属性里面的值，计算属性只读</li>\\n<li>可以关联多个实时计算的对象，相比起来，侦听器只能侦听一个数据的变化</li>\\n</ul>","autoDesc":true}');export{e as data};
