import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,f as e}from"./app-9e438faa.js";const o={},t=e(`<p>地址：https://www.freecodecamp.org/chinese/news/var-let-and-const-whats-the-difference/</p><h2 id="我的总结" tabindex="-1"><a class="header-anchor" href="#我的总结" aria-hidden="true">#</a> 我的总结</h2><p>为什么使用let?</p><ol><li>即使是同名变量，如果在同一个作用域内，我们使用let无法重新声明同一个变量，而var可以，这可以避免我们不小心覆盖了之前的变量而不知道；</li><li>在不同的作用域内，我们可以声明同名变量，但是是彼此分隔不影响的，这就是使用let的好处(var关键字也有好处2)</li></ol><p>ES2015（ES6）出现了许多闪亮的新功能。许多 JavaScript 开发人员已经熟悉并开始使用这些功能，但其中一些功能对某些开发人员来说可能仍然是个谜。</p><p>ES6 的特性之一是添加了 <code>let</code> 和 <code>const</code>，可用于变量声明。问题是，是什么让它们与我们一直在使用的 <code>var</code> 不同？如果你仍然不清楚这一点，那么本文适合你。</p><p>在本文中，我们将讨论 <code>var</code>、<code>let</code> 和 <code>const</code> 的范围、使用和提升。当你阅读时，请注意我将指出的它们之间的差异。</p><h2 id="var" tabindex="-1"><a class="header-anchor" href="#var" aria-hidden="true">#</a> <strong>Var</strong></h2><p>在 ES6 出现之前，<code>var</code> 声明占主导地位。但是，使用 <code>var</code> 声明的变量存在一些问题。这就是为什么有必要出现新的声明变量的方法。首先，在讨论这些问题之前，让我们更多地了解 <code>var</code>。</p><h3 id="var-的作用域" tabindex="-1"><a class="header-anchor" href="#var-的作用域" aria-hidden="true">#</a> var 的作用域</h3><p>作用域（scope）意味着这些变量可以在哪里使用。<code>var</code> 声明的作用域是全局的或函数/局部的。</p><p>当 <code>var</code> 变量在函数外部声明时，作用域是全局的。这意味着在函数体外用 <code>var</code> 声明的任何变量都可以在整个窗口和任意函数内部使用。</p><p><code>var</code> 在函数中声明时，它的作用域是在函数体内。这意味着它只能在该函数中被访问。</p><p>要进一步了解，请查看下面的示例。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    <span class="token keyword">var</span> greeter <span class="token operator">=</span> <span class="token string">&quot;hey hi&quot;</span><span class="token punctuation">;</span>
    
    <span class="token keyword">function</span> <span class="token function">newFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> hello <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，<code>greeter</code> 是全局作用域的，因为它存在于函数之外，而 <code>hello</code> 是函数作用域，所以我们不能在函数之外访问变量 <code>hello</code>。所以如果我们这样做：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    <span class="token keyword">var</span> tester <span class="token operator">=</span> <span class="token string">&quot;hey hi&quot;</span><span class="token punctuation">;</span>
    
    <span class="token keyword">function</span> <span class="token function">newFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> hello <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error: hello is not defined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们会得到一个错误，这是由于 <code>hello</code> 在函数之外不可用。</p><h3 id="var-变量可以重新声明和更新" tabindex="-1"><a class="header-anchor" href="#var-变量可以重新声明和更新" aria-hidden="true">#</a> var 变量可以重新声明和更新</h3><p>这意味着我们可以在相同的作用域内执行此操作，并且不会出错。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    <span class="token keyword">var</span> greeter <span class="token operator">=</span> <span class="token string">&quot;hey hi&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> greeter <span class="token operator">=</span> <span class="token string">&quot;say Hello instead&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>同时</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    <span class="token keyword">var</span> greeter <span class="token operator">=</span> <span class="token string">&quot;hey hi&quot;</span><span class="token punctuation">;</span>
    greeter <span class="token operator">=</span> <span class="token string">&quot;say Hello instead&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="var-的提升" tabindex="-1"><a class="header-anchor" href="#var-的提升" aria-hidden="true">#</a> var 的提升</h3><p>提升（hoisting）是一种 JavaScript 机制，其中变量和函数声明在代码执行之前被移动到其作用域的顶部。这意味着，如果我们这样做：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    console<span class="token punctuation">.</span><span class="token function">log</span> <span class="token punctuation">(</span>greeter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> greeter <span class="token operator">=</span> <span class="token string">&quot;say hello&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>它被解释为：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    <span class="token keyword">var</span> greeter<span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>greeter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// greeter is undefined</span>
    greeter <span class="token operator">=</span> <span class="token string">&quot;say hello&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此 <code>var</code> 变量被提升到其作用域的顶部，并使用 <code>undefined</code> 值进行初始化。</p><h3 id="var-的问题" tabindex="-1"><a class="header-anchor" href="#var-的问题" aria-hidden="true">#</a> var 的问题</h3><p><code>var</code> 有一个弱点，我将使用下面的例子来解释：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    <span class="token keyword">var</span> greeter <span class="token operator">=</span> <span class="token string">&quot;hey hi&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> times <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>times <span class="token operator">&gt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> greeter <span class="token operator">=</span> <span class="token string">&quot;say Hello instead&quot;</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
    
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>greeter<span class="token punctuation">)</span> <span class="token comment">// &quot;say Hello instead&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，由于 <code>times &gt; 3</code> 返回 <code>true</code>，<code>greeter</code> 被重新定义为 <code>&quot;say Hello instead&quot;</code>。如果你有意要重新定义 <code>greeter</code>，这不是问题，但当你没有意识到之前已经定义了一个变量 <code>greeter</code> 时，它就会成为问题。</p><p>如果你在代码的其他部分使用了 <code>greeter</code>，你可能会对得到的输出感到惊讶。这可能会导致你的代码中出现很多错误。这就是为什么 <code>let</code> 和 <code>const</code> 是必要的。</p><h2 id="let" tabindex="-1"><a class="header-anchor" href="#let" aria-hidden="true">#</a> <strong>Let</strong></h2><p><code>let</code> 现在是变量声明的首选。这并不奇怪，因为它是对 <code>var</code> 声明的改进。它还解决了我们刚刚介绍的 <code>var</code> 的问题。让我们考虑一下为什么会这样。</p><h3 id="let-是块作用域" tabindex="-1"><a class="header-anchor" href="#let-是块作用域" aria-hidden="true">#</a> let 是块作用域</h3><p>块是由 <code>{}</code> 界定的代码块。一个块存在于花括号中。花括号内的任何内容都是一个块。</p><p>因此，在带有 <code>let</code> 的块中声明的变量只能在该块中使用。让我用一个例子来解释一下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>   <span class="token keyword">let</span> greeting <span class="token operator">=</span> <span class="token string">&quot;say Hi&quot;</span><span class="token punctuation">;</span>
   <span class="token keyword">let</span> times <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span>times <span class="token operator">&gt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token string">&quot;say Hello instead&quot;</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// &quot;say Hello instead&quot;</span>
    <span class="token punctuation">}</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span> <span class="token comment">// hello is not defined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看到在它的块（定义它的花括号）之外使用 <code>hello</code> 会返回一个错误。这是因为 <code>let</code> 变量是块作用域的。</p><h3 id="let-可以更新但不能重新声明" tabindex="-1"><a class="header-anchor" href="#let-可以更新但不能重新声明" aria-hidden="true">#</a> let 可以更新但不能重新声明</h3><p>就像 <code>var</code> 一样，使用 <code>let</code> 声明的变量可以在其作用域内更新。与 <code>var</code> 不同，<code>let</code> 变量不能在其作用域内重新声明。所以虽然这会运行：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    <span class="token keyword">let</span> greeting <span class="token operator">=</span> <span class="token string">&quot;say Hi&quot;</span><span class="token punctuation">;</span>
    greeting <span class="token operator">=</span> <span class="token string">&quot;say Hello instead&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这将返回一个错误：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    <span class="token keyword">let</span> greeting <span class="token operator">=</span> <span class="token string">&quot;say Hi&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> greeting <span class="token operator">=</span> <span class="token string">&quot;say Hello instead&quot;</span><span class="token punctuation">;</span> <span class="token comment">// error: Identifier &#39;greeting&#39; has already been declared</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，如果同一个变量定义在不同的作用域，就不会报错：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    <span class="token keyword">let</span> greeting <span class="token operator">=</span> <span class="token string">&quot;say Hi&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> greeting <span class="token operator">=</span> <span class="token string">&quot;say Hello instead&quot;</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;say Hello instead&quot;</span>
    <span class="token punctuation">}</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;say Hi&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么没有错误？这是因为两个实例都被视为不同的变量，因为它们具有不同的作用域。</p><p>这一事实使 <code>let</code> 成为比 <code>var</code> 更好的选择。使用 <code>let</code> 时，如果你以前使用过变量名称，则不必担心，因为变量仅存在于其作用域内。</p><p>此外，由于一个变量不能在一个作用域内多次声明，那么前面讨论的 <code>var</code> 出现的问题就不会发生。</p><h3 id="let-的提升" tabindex="-1"><a class="header-anchor" href="#let-的提升" aria-hidden="true">#</a> <strong>let 的提升</strong></h3><p>就像 <code>var</code> 一样，<code>let</code> 声明被提升到顶部。与初始化为 <code>undefined</code> 的 <code>var</code> 不同，<code>let</code> 关键字未初始化。所以如果你在声明之前尝试使用 <code>let</code> 变量，你会得到一个 <code>Reference Error</code>。</p><h2 id="const" tabindex="-1"><a class="header-anchor" href="#const" aria-hidden="true">#</a> <strong>Const</strong></h2><p>用 <code>const</code> 声明的变量保持恒定值。 <code>const</code> 声明与 <code>let</code> 声明有一些相似之处。</p><h3 id="const-声明是块作用域" tabindex="-1"><a class="header-anchor" href="#const-声明是块作用域" aria-hidden="true">#</a> const 声明是块作用域</h3><p>与 <code>let</code> 声明一样，<code>const</code> 声明只能在它们声明的块内访问。</p><h3 id="const-不能更新或重新声明" tabindex="-1"><a class="header-anchor" href="#const-不能更新或重新声明" aria-hidden="true">#</a> const 不能更新或重新声明</h3><p>这意味着用 <code>const</code> 声明的变量的值在其作用域内保持不变。它不能被更新或重新声明。所以如果我们用 <code>const</code> 声明一个变量，我们不能这样做：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    <span class="token keyword">const</span> greeting <span class="token operator">=</span> <span class="token string">&quot;say Hi&quot;</span><span class="token punctuation">;</span>
    greeting <span class="token operator">=</span> <span class="token string">&quot;say Hello instead&quot;</span><span class="token punctuation">;</span><span class="token comment">// error: Assignment to constant variable. </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>也不能这样：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    <span class="token keyword">const</span> greeting <span class="token operator">=</span> <span class="token string">&quot;say Hi&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> greeting <span class="token operator">=</span> <span class="token string">&quot;say Hello instead&quot;</span><span class="token punctuation">;</span><span class="token comment">// error: Identifier &#39;greeting&#39; has already been declared</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，每个 <code>const</code> 声明都必须在声明时进行初始化。</p><p>当涉及到用 <code>const</code> 声明的对象时，这种行为在某种程度上有所不同。虽然无法更新 <code>const</code> 对象，但可以更新此对象的属性。因此，如果我们这样声明一个 <code>const</code> 对象：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    <span class="token keyword">const</span> greeting <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">&quot;say Hi&quot;</span><span class="token punctuation">,</span>
        <span class="token literal-property property">times</span><span class="token operator">:</span> <span class="token number">4</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然我们不能这样做：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    greeting <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">words</span><span class="token operator">:</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">,</span>
        <span class="token literal-property property">number</span><span class="token operator">:</span> <span class="token string">&quot;five&quot;</span>
    <span class="token punctuation">}</span> <span class="token comment">// error:  Assignment to constant variable.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但可以这样操作：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    greeting<span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">&quot;say Hello instead&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这将更新 <code>greeting.message</code> 的值而不返回错误。</p><h3 id="const-的提升" tabindex="-1"><a class="header-anchor" href="#const-的提升" aria-hidden="true">#</a> <strong>const 的提升</strong></h3><p>就像 <code>let</code> 一样，<code>const</code> 声明被提升到顶部但没有被初始化。</p><p>这三个声明方法有以下区别：</p><ul><li><code>var</code> 声明是全局作用域或函数作用域，而 <code>let</code> 和 <code>const</code> 是块作用域。</li><li><code>var</code> 变量可以在其作用域内更新和重新声明；<code>let</code> 变量可以更新但不能重新声明；<code>const</code> 变量既不能更新也不能重新声明。</li><li>它们都被提升到了作用域的顶部。但是，<code>var</code> 变量是用 <code>undefined</code> 初始化的，而 <code>let</code> 和 <code>const</code> 变量不会被初始化。</li><li><code>var</code> 和 <code>let</code> 可以在不初始化的情况下声明，而 <code>const</code> 必须在声明时初始化。</li></ul>`,74),c=[t];function p(i,l){return s(),a("div",null,c)}const u=n(o,[["render",p],["__file","声明变量的方式：var_let和const.html.vue"]]);export{u as default};
