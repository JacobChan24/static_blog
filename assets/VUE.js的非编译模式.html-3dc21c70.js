import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as a,f as l}from"./app-9e438faa.js";const s={},t=l('<p>一般情况下，生产环境报错后，我们比较难根据生产环境编译后的代码来反推到我们的源码来定位问题，因为vue.js的语法浏览器默认是不支持的，我们需要通过将其编译成在浏览器中直接运行的javascript和css</p><ul><li>我们需要知道脱离了Vite, Webpack等构建工具之后，如何使vue也能在浏览器中运行，这就需要我们知道vue.js在非编译的情况下如何运行</li></ul><p>Vue.js 代码的编译过程中，主要进行了以下的操作流程：</p><ol><li>把 Vue.js 代码里的模板编译成基于 JavaScript 代码描述的 VNode（虚拟节点）；</li><li>把 Vue.js 代码里 JavaScript 逻辑代码，编译成运行时对应生命周期的逻辑代码；</li><li>最后是把内置的 CSS 样式代码抽离出来。</li></ol><p>从上面的描述，我们可以总结一下，Vue.js 经过编译后产出是 JavaScript（描述模板和生命周期的逻辑） 和 CSS 代码，也就是浏览可以直接支持运行的代码。</p><h3 id="为什么需要知道非编译模式" tabindex="-1"><a class="header-anchor" href="#为什么需要知道非编译模式" aria-hidden="true">#</a> 为什么需要知道非编译模式？</h3><ul><li>需要在离开了通用的开发模式之后，还能掌握其他方式来快速无缝衔接使用这个技术框架</li><li>enable us能够跳过开发编译的阶段，直接在浏览器里面组装vue.js代码结构，动态渲染出想要的页面功能，这就是低代码的场景（因为编译器无法一句一句地编译语句，只能一次性将代码编译成脚本然后再运行）</li></ul>',7),c=[t];function r(_,o){return i(),a("div",null,c)}const p=e(s,[["render",r],["__file","VUE.js的非编译模式.html.vue"]]);export{p as default};
