import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o as c,c as i,a as n,b as a,d as e,f as t}from"./app-9e438faa.js";const l={},d=t(`<h2 id="我的总结" tabindex="-1"><a class="header-anchor" href="#我的总结" aria-hidden="true">#</a> 我的总结</h2><h4 id="模块化导出-export" tabindex="-1"><a class="header-anchor" href="#模块化导出-export" aria-hidden="true">#</a> 模块化导出 - export</h4><p>export语句用于规定对外的接口，外部通过此接口import的值也是随之动态变化的，export语句只能写在模块的顶层作用域，不能写在模块内的块级作用域 具体写法:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>export {b,a}    //已经定义好的变量或者函数
export var/let/const a = 1/{}/true/function(){}    //定义导出一起搞
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>比较特别的是<code>export default</code>语句，一般使用场景下，我们会假设开发者已经知道需要加载的变量名或者函数名，但是不排除不知道的，所以这种方式可以让开发者指定默认输出，但是一个模块只能有一个默认输出，即一个模块里面只能使用一次该命令，<code>export default</code>输出了一个叫做<code>default</code>的变量或者方法，引入时我们可以取任意的名字</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>export default b

import anyName from &#39;xxx&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="加载模块-import" tabindex="-1"><a class="header-anchor" href="#加载模块-import" aria-hidden="true">#</a> 加载模块 - import</h4><p>import时不能使用任何表达式和变量，因为加载模块不是在javascript运行时载入的，是在编译时载入的 如果需要在运行时加载模块，需要用到Node的<a href="%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97">require方法</a></p><hr><p>ES Module 系列：</p>`,10),r={href:"https://link.juejin.cn?target=http%3A%2F%2Fwww.wawow.xyz%2F%23%2Fmd-render%3Fbid%3D39",title:"http://www.wawow.xyz/#/md-render?bid=39",target:"_blank",rel:"noopener noreferrer"},u={href:"https://link.juejin.cn?target=http%3A%2F%2Fwww.wawow.xyz%2F%23%2Fmd-render%3Fbid%3D40",title:"http://www.wawow.xyz/#/md-render?bid=40",target:"_blank",rel:"noopener noreferrer"},k=t('<h2 id="一、什么是es-module" tabindex="-1"><a class="header-anchor" href="#一、什么是es-module" aria-hidden="true">#</a> 一、什么是ES Module</h2><blockquote><p>历史上，JavaScript 一直没有模块（module）体系，<strong>无法将一个大程序拆分成互相依赖的小文件</strong>，再用简单的方法拼装起来。其他语言都有这项功能，比Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 **CommonJS 和 AMD **两种。前者用于服务器，后者用于浏览器。</p><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块的设计思想是尽量的<strong>静态化</strong>，使得<strong>编译时就能确定模块的依赖关系</strong>，以及输入和输出的变量。</p><p>CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p></blockquote><h3 id="can-i-use" tabindex="-1"><a class="header-anchor" href="#can-i-use" aria-hidden="true">#</a> Can I Use</h3>',3),m={href:"https://link.juejin.cn?target=https%3A%2F%2Fcaniuse.com%2F%3Fsearch%3Desm",title:"https://caniuse.com/?search=esm",target:"_blank",rel:"noopener noreferrer"},v=n("strong",null,"93%",-1),h=t(`<figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e6a02071c624a04bfa38c971565d71a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="es-module-和-commonjs" tabindex="-1"><a class="header-anchor" href="#es-module-和-commonjs" aria-hidden="true">#</a> ES Module 和 CommonJS</h3><h4 id="区别" tabindex="-1"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h4><ul><li>ES Module 输出的是值的引用，而 CommonJS 输出的是值的拷贝；</li><li>ES Module 是编译时执行，而 CommonJS 模块是在运行时加载；</li><li>ES6 Module可以导出多个值，而CommonJs 是单个值导出；</li><li>ES6 Module 静态语法只能写在顶层，而CommonJs 是动态语法可以写在判断里；</li><li>ES6 Module的 this 是 undefined，而CommonJs 的 this 是当前模块；</li></ul><h4 id="使用比较" tabindex="-1"><a class="header-anchor" href="#使用比较" aria-hidden="true">#</a> 使用比较</h4><h5 id="commonjs模块" tabindex="-1"><a class="header-anchor" href="#commonjs模块" aria-hidden="true">#</a> CommonJS模块</h5><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// CommonJS模块</span>
<span class="token keyword">let</span> <span class="token punctuation">{</span> stat<span class="token punctuation">,</span> exists<span class="token punctuation">,</span> readfile <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;fs&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 等同于</span>
<span class="token keyword">let</span> _fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;fs&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> stat <span class="token operator">=</span> _fs<span class="token punctuation">.</span>stat<span class="token punctuation">;</span>
<span class="token keyword">let</span> exists <span class="token operator">=</span> _fs<span class="token punctuation">.</span>exists<span class="token punctuation">;</span>
<span class="token keyword">let</span> readfile <span class="token operator">=</span> _fs<span class="token punctuation">.</span>readfile<span class="token punctuation">;</span>
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>CommonJS模块</strong>代码的实质是整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。</p><p>这种加载称为**“运行时加载”**，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p><h5 id="es6模块" tabindex="-1"><a class="header-anchor" href="#es6模块" aria-hidden="true">#</a> ES6模块</h5><p>ES6 模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// ES6模块</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> stat<span class="token punctuation">,</span> exists<span class="token punctuation">,</span> readFile <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;fs&#39;</span><span class="token punctuation">;</span>
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>ES6模块</strong>代码的实质是从<code>fs</code>模块加载 3 个方法，其他方法不加载。这种加载称为**“编译时加载”或者静态加载**，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p><p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和**类型检验（type system）**这些只能靠静态分析实现的功能。</p><p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p><ul><li>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。</li><li>浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li><li>不再需要对象作为命名空间（比如<code>Math</code>对象），这些功能可以通过模块提供。</li></ul><h2 id="二、es-module-语法" tabindex="-1"><a class="header-anchor" href="#二、es-module-语法" aria-hidden="true">#</a> 二、ES Module 语法</h2><h3 id="_1、export-命令" tabindex="-1"><a class="header-anchor" href="#_1、export-命令" aria-hidden="true">#</a> 1、export 命令</h3><ul><li><code>export</code>命令用于规定模块的对外接口，即允许外部引用的部分；</li><li><code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系；</li><li><code>export</code>语句输出的接口，与其对应的值是动态绑定关系（可以理解为引用类型），即通过该接口，可以取到模块内部<strong>实时的值</strong>；</li><li><code>export</code>命令可以出现在模块顶层作用域的任何位置。如果处于块级作用域内，就会报错；</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// export</span>

<span class="token comment">// export方式1</span>
<span class="token keyword">export</span> <span class="token keyword">var</span><span class="token operator">/</span><span class="token keyword">let</span><span class="token operator">/</span><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token operator">/</span><span class="token number">1</span><span class="token operator">/</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token keyword">class</span><span class="token operator">/</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//导出的可以是类型类型，包括类（class）</span>

<span class="token comment">// export方式2</span>
<span class="token keyword">var</span><span class="token operator">/</span><span class="token keyword">let</span><span class="token operator">/</span><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token operator">/</span><span class="token number">1</span><span class="token operator">/</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token keyword">class</span><span class="token operator">/</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span>b<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// export方式3：export命令除了输出变量，还可以输出函数或类（class）</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">addNum</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2、import-命令" tabindex="-1"><a class="header-anchor" href="#_2、import-命令" aria-hidden="true">#</a> 2、import 命令</h3><ul><li><code>import</code>命令用于输入其他模块提供的功能，通过<code>import</code>命令加载引入模块；</li><li><code>import</code>命令输入的变量都是只读的，它的本质是输入接口，不允许在加载模块的文件中修改进入变量的值；但是如果<code>引入变量</code>是一个对象，改写<code>引入变量</code>的属性是允许的；</li><li><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径；</li><li><code>import</code>命令具有提升效果，会提升到整个模块作用域的头部，首先执行；</li><li><code>import</code>是静态执行，引入语句中<strong>不能使用表达式和变量</strong>（表达式和变量是在运行时才能得到结果的语法结构）；</li><li><code>import</code>语句会执行所加载的模块，重复执行同一句<code>import</code>语句，那么只会执行一次；</li><li><code>import</code>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个引入对象，所有输出值都加载在这个对象上；</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 引入提升</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> a <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;test&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// 整体引入</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> b <span class="token keyword">from</span> <span class="token string">&#39;test&#39;</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 修改引入对象的属性</span>
b<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="静态执行特点" tabindex="-1"><a class="header-anchor" href="#静态执行特点" aria-hidden="true">#</a> 静态执行特点</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 报错：引入使用 表达式</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token string">&#39;he&#39;</span> <span class="token operator">+</span> <span class="token string">&#39;llo&#39;</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;sayHi&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// 报错：引入使用 变量</span>
<span class="token keyword">let</span> module <span class="token operator">=</span> <span class="token string">&#39;sayHi&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> hello <span class="token punctuation">}</span> from module<span class="token punctuation">;</span>

<span class="token comment">// 报错：引入使用 代码块结构</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">import</span> <span class="token punctuation">{</span> hello <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;sayHi&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token keyword">import</span> <span class="token punctuation">{</span> baybay <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;sayHi&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面引入都会报错，因为<strong>在静态分析阶段，这些语法都是没法得到值的</strong>。</p><h4 id="报错原因" tabindex="-1"><a class="header-anchor" href="#报错原因" aria-hidden="true">#</a> 报错原因</h4><p><code>import</code>命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行；</p><p>引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<strong>表达式、变量和代码块结构</strong>，所以<code>import</code>语句中包含表达式、变量或者放在代码块结构没有意义。</p><h3 id="_3、export-default" tabindex="-1"><a class="header-anchor" href="#_3、export-default" aria-hidden="true">#</a> 3、export default</h3><p>按照正常逻辑，使用<code>import</code>命令的时候，开发者需要知道所要加载的变量名或函数名，否则无法加载，但是为了方便开发者使用，不拘泥于文档说明，于是提供了<strong>export default</strong>命令，为模块指定默认输出。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// export-default</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;sayHi&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// import-default</span>
<span class="token keyword">import</span> dfName <span class="token keyword">from</span> <span class="token string">&#39;./export-default&#39;</span><span class="token punctuation">;</span>
<span class="token function">dfName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;sayHi&#39;</span>
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="区别-1" tabindex="-1"><a class="header-anchor" href="#区别-1" aria-hidden="true">#</a> 区别</h4><p>一个模块只能有一个默认输出，<code>export default</code> 命令只能使用一次；对于<code>import</code>命令后面不用加大括号，因为只有唯一对应<code>export default</code>命令。</p><p>本质：<code>export default</code>输出了一个叫做<code>default</code>的变量或方法，引入时系统允许你为它取任意名字；</p><p><code>import</code>语句中，可以同时输入<strong>默认方法</strong>和<strong>其他接口</strong>：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> _<span class="token punctuation">,</span> <span class="token punctuation">{</span> hello <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;sayHi&#39;</span><span class="token punctuation">;</span>
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>对应<code>export</code>:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ···</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ···</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token punctuation">{</span> hello <span class="token punctuation">}</span><span class="token punctuation">;</span>
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4、export-与-import-的复合" tabindex="-1"><a class="header-anchor" href="#_4、export-与-import-的复合" aria-hidden="true">#</a> 4、export 与 import 的复合</h3><p>在一个模块之中，先输入一个模块，最后再输出同一个模块：</p><p>注意：写成一行的方式中，<strong>hello</strong>实际上并没有被导入当前模块，只是相当于对外转发了这个接口，于是当前模块不能使用<strong>hello</strong>。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token punctuation">{</span> hello <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;sayHi&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// 理解为</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> hello <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;sayHi&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> hello <span class="token punctuation">}</span><span class="token punctuation">;</span>
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5、import" tabindex="-1"><a class="header-anchor" href="#_5、import" aria-hidden="true">#</a> 5、import()</h3><h4 id="import的不足" tabindex="-1"><a class="header-anchor" href="#import的不足" aria-hidden="true">#</a> import的不足</h4><p><code>import</code>静态分析有利于编译器提高效率，但导致<strong>无法在运行时加载模块</strong>。因此，条件加载就无法实现。</p><p>因此<code>import</code>无法取代 Node 的<code>require</code>方法。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token string">&#39;./&#39;</span> <span class="token operator">+</span> fileNamePath<span class="token punctuation">;</span>
<span class="token keyword">const</span> myModual <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="import-函数" tabindex="-1"><a class="header-anchor" href="#import-函数" aria-hidden="true">#</a> import()函数</h4>`,49),b=n("code",null,"import()",-1),g={href:"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-dynamic-import",title:"https://github.com/tc39/proposal-dynamic-import",target:"_blank",rel:"noopener noreferrer"},f=t(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span>
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><code>import</code>函数的参数<code>from</code>，即加载的模块的位置。</p></li><li><p><code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。</p></li><li><p><code>import()</code>返回一个 Promise <strong>对象</strong>；</p></li></ul><h5 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h5><ul><li><code>import()</code>函数可以用在任何地方，模块，非模块的脚本都可以使用；</li><li>运行时执行（什么时候运行到这一句，就会加载指定的模块）；</li><li><code>import()</code>函数与所加载的模块不是静态连接关系，与<code>import</code>语句完全不同；</li><li><code>import()</code>更像<code>require</code>方法，主要区别是<code>import()</code>是异步加载，<code>require</code>是同步加载；</li></ul><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>`,5),x={href:"https://link.juejin.cn?target=https%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fmodule",title:"https://es6.ruanyifeng.com/#docs/module",target:"_blank",rel:"noopener noreferrer"},w=n("h1",{id:"es-module原理详解",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#es-module原理详解","aria-hidden":"true"},"#"),a(" ES Module原理详解")],-1),y=n("figure",null,[n("img",{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e0012609d41466b83c5773f80caf01c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image",alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1),_=n("p",null,"ES Module 系列：",-1),j={href:"https://link.juejin.cn?target=http%3A%2F%2Fwww.wawow.xyz%2F%23%2Fmd-render%3Fbid%3D39",title:"http://www.wawow.xyz/#/md-render?bid=39",target:"_blank",rel:"noopener noreferrer"},S={href:"https://link.juejin.cn?target=http%3A%2F%2Fwww.wawow.xyz%2F%23%2Fmd-render%3Fbid%3D40",title:"http://www.wawow.xyz/#/md-render?bid=40",target:"_blank",rel:"noopener noreferrer"},M=t(`<h2 id="一、es-modules如何工作" tabindex="-1"><a class="header-anchor" href="#一、es-modules如何工作" aria-hidden="true">#</a> 一、ES Modules如何工作</h2><p>当前，在浏览器中通过 <code>&lt;script type=&quot;module&quot;&gt;</code> 已原生支持 ESM。以<strong>vite</strong>创建的<strong>Vue3</strong>项目为例：</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code>// index.html文件
<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>UTF-8<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>icon<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>favicon.png<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>width=device-width, initial-scale=1.0<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>xxxx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>app<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>module<span class="token punctuation">&quot;</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/src/main.ts<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>/src/main.ts</code>是Vue3的入口文件。</p><p>注意：浏览器中<code>ES Module</code>是异步加载，不会堵塞浏览器，即等到整个页面渲染完，再执行模块脚本。如果网页有多个<code>ESM</code>，它们会按照在页面出现的顺序依次执行。</p><h3 id="流程简析" tabindex="-1"><a class="header-anchor" href="#流程简析" aria-hidden="true">#</a> 流程简析</h3><p>1、创建AST</p><p>当使用<code>ES Modules</code>进行开发时，实际上以入口节点为根节点（如main.js）创建出一张依赖关系图。不同依赖项之间通过<code>export\\import</code>语句来进行关联。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa36da8ff45c4956a9c102a56edaf1bd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>2、生成 Module Record</p><p>浏览器无法直接使用文件本身，但是浏览器会解析这些文件，根据 <code>import/export</code> 语句构成模块记录(<code>Module Record</code>)，每个模块文件对应生成一个 <code>Module Record</code>，记录当前模块的信息：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62e58507e1d647f8bcd4671c63823c2d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>3、转化 Module Instance</p><p>模块记录转化为模块实例，浏览器最终能够读取也就是<code>Module Instance</code>。</p><h2 id="二、模块加载" tabindex="-1"><a class="header-anchor" href="#二、模块加载" aria-hidden="true">#</a> 二、模块加载</h2><p>模块加载的过程就是从入口文件到拥有一个完整的模块实例图的过程，对于 ES Module 来说，分三步进行：</p><p><code>构造</code>：查找、下载并解析所有文件到模块记录中。</p><p><code>实例化</code>：在内存中寻找一块区域来存储所有导出的变量（但还没有填充值）。然后让 export 和 import 都指向这些内存块。这个过程叫做链接（linking）</p><p><code>求值</code>：在内存块中填入变量的实际值。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e65af98f0320481fb07b9463f7235e62~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_1、构造" tabindex="-1"><a class="header-anchor" href="#_1、构造" aria-hidden="true">#</a> 1、构造</h3><p>在构造阶段，每个模块都会经历三件事情：</p><ul><li><p>查找：找出从哪里下载包含该模块的文件（也称为模块解析）；</p><blockquote><p>通常会有一个入口文件，然后通过<code>import</code>代码去寻找与之关联的其他模块，形成一个<code>依赖关系树（AST）</code>；</p></blockquote></li><li><p>下载：获取文件（从 URL 下载或从文件系统加载）；</p><blockquote><p>解析文件前，需要一层一层地遍历树，找出它的依赖项，然后找到并加载这些依赖项；</p></blockquote></li><li><p>解析：将文件解析为模块记录；</p><blockquote><p>把解析出来的模块构成表 称为 <code>Module Record</code> （模块记录）。</p><p><code>Module Record</code> 包含了当前模块的 <code>AST</code>，引用了哪些模块的变量，以及一些特定属性和方法。</p><p>一旦 <code>Module Record</code> 被创建，它会被记录在模块映射<code>Module Map</code>中。被记录后，如果再有对相同 <code>URL</code> 的请求，<code>Loader</code> 将直接采用 <code>Module Map</code> 中 <code>URL</code> 对应的<code>Module Record</code>。</p></blockquote></li></ul><p>在构造过程结束时，从主入口文件变成了一堆模块记录<code>Module Record</code>：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20e39b886bc2419a8ee4946fa7c2a76b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2、实例化" tabindex="-1"><a class="header-anchor" href="#_2、实例化" aria-hidden="true">#</a> 2、实例化</h3><p>实例化阶段：将构造的模块实例化并将所有实例链接在一起。</p><p>模块实例包含两部分：<strong>代码、状态</strong>。</p><p>状态存在于内存中，因此实例化步骤就是写入内存。</p><p>首先，JS引擎创建一个模块环境记录(<code>Module Enviroment Record</code>)来管理 <code>Module Record</code> 的变量。然后它在内存中找到所有导出内容对应的位置。模块环境记录将跟踪内存中导出内容对应的位置与导出内容间的联系。</p><p>此时内存中的这些位置中还不会存放值，只有在计算后才会有值。</p><blockquote><p>注意，导出和导入都指向内存中的同一位置。首先链接导出，可确保所有导入都可以链接到匹配的导出。</p><p>ES Module 的这种连接方式被称为 Live Bindings（动态绑定）;</p><p>ES 模块使用称为动态绑定的东西。两个模块都指向内存中的相同位置。这意味着当导出模块更改值时，该更改将显示在导入模块中。导出值的模块可以随时更改这些值，但导入模块不能更改其导入的值，虽然有此限制，但是如果一个模块导入一个对象，导入模块中可以更改该对象上的属性值。</p></blockquote><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d488a88cfcbb43e5944c346a008e0182~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>拥有这样的<strong>动态绑定</strong>可以使我们在不运行任何代码的情况下连接所有模块。</p><p>实例化结束时，已经连接了<code>export/import</code>变量的所有实例和内存位置。</p><h3 id="_3、求值" tabindex="-1"><a class="header-anchor" href="#_3、求值" aria-hidden="true">#</a> 3、求值</h3><p>最后一步，在内存区中填充绑定的数据的值。</p><p>JS 引擎通过执行顶层代码（函数之外的代码，此处可以理解为模块文件中顶层作用域中的代码）来给内存区的引用赋值。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a224f2e49e78450680f8fc820065ffa4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><p>ES Module执行分为三个阶段：构造阶段、实例化阶段、求值阶段</p></li><li><p>构造阶段:</p><blockquote><ul><li>1、根据入口创建依赖关系的AST;</li><li>2、下载module文件，用于解析；</li><li>3、解析每个module文件，生成 Module Record（包含当前module的AST、变量等）；</li><li>4、将Module Record 映射到 Module Map中，保持每个module文件的唯一性；</li></ul></blockquote><p>构造阶段最后生成根据依赖关系AST的 Module Record的依赖树，同时将每个Module Record映射保存到Module Map中。</p></li><li><p>实例化阶段：</p><blockquote><ul><li>1、生成模每个Module Record的块环境记录(<code>Module Enviroment Record</code>)，用来管理 <code>Module Record</code> 的变量等；</li><li>2、在内存中写入每个Module的数据，同时 Module文件的导出export和引用文件的 import指向该地址；</li></ul></blockquote><p>实例化阶段确定了 <code>export和import</code>内存中的指向，同时该内存空间中定义了Module文件的变量（但是还未赋值）；</p></li><li><p>求值阶段：</p><blockquote><ul><li>1、执行对应Module文件中顶层作用域的代码，确定实例化阶段中定义变量的值，放入内存中；</li></ul></blockquote><p>求值阶段确定了Module文件中变量的值，由于 ES Module使用的是动态绑定（指向内存地址），export中修改数据会映射到内存中，import数据相应也会改变。</p></li></ul><h2 id="参考-1" tabindex="-1"><a class="header-anchor" href="#参考-1" aria-hidden="true">#</a> 参考</h2>`,42),E={href:"https://link.juejin.cn?target=https%3A%2F%2Fhacks.mozilla.org%2F2018%2F03%2Fes-modules-a-cartoon-deep-dive%2F",title:"https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/",target:"_blank",rel:"noopener noreferrer"},q=n("p",null,[a("作者：wawoweb"),n("br"),a(" 链接：https://juejin.cn/post/7098192216229117959"),n("br"),a(" 来源：稀土掘金"),n("br"),a(" 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。")],-1);function F(z,A){const s=p("ExternalLinkIcon");return c(),i("div",null,[d,n("ul",null,[n("li",null,[n("p",null,[n("a",r,[a("ES Module使用详解"),e(s)])])]),n("li",null,[n("p",null,[n("a",u,[a("ES Module原理详解"),e(s)])])])]),k,n("p",null,[a("截止本篇文章为止（2022-05-15），通过参看"),n("a",m,[a("Can I Use"),e(s)]),a("上ES Module的使用情况可知：在浏览器中的整体使用率为 "),v,a("，在各大主流浏览器都得到支持（除IE外）。")]),h,n("p",null,[b,a("函数在"),n("a",g,[a("ES2020提案"),e(s)]),a(" 中被引入，用以支持动态加载模块。")]),f,n("ul",null,[n("li",null,[n("a",x,[a("ECMAScript6入门—ES Module"),e(s)])])]),w,y,_,n("ul",null,[n("li",null,[n("p",null,[n("a",j,[a("ES Module使用详解"),e(s)])])]),n("li",null,[n("p",null,[n("a",S,[a("ES Module原理详解"),e(s)])])])]),M,n("p",null,[n("a",E,[a("ES modules: A cartoon deep-dive"),e(s)])]),q])}const R=o(l,[["render",F],["__file","ES module 模块的具体使用.html.vue"]]);export{R as default};
