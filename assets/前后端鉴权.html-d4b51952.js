import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as i,f as p}from"./app-9e438faa.js";const n={},t=p('<p>前言</p><p>还记得之前在面试的时候，有一位面试官就问了，关于前端鉴权这块，<code>Token、Cookie、Session、JWT、单点登录</code>是什么？有什么作用？你一般是怎么做的？以及你是怎么存储的呢？那你又是怎么保证 <code>它</code> 的安全的呢？</p><p>一顿连问下来，我是焦头又烂额，欲言而又止.......</p><p>其实鉴权的方法有很多，下面我总结了常用的 <code>10种鉴权方法</code>，那么哪一种是最适合你的系统呢？哪一种又最安全呢？</p><p>那就让我们从下文慢慢探索寻找答案吧 ~</p><h2 id="通过这篇文章你将学到什么" tabindex="-1"><a class="header-anchor" href="#通过这篇文章你将学到什么" aria-hidden="true">#</a> 通过这篇文章你将学到什么？</h2><figure><img src="https://mmbiz.qpic.cn/mmbiz/mshqAkialV7Gonk6JI5LwQu1uS9fWP6JwiaA3s0nDPfSyB965ribFkqef8cqoRUWoBEw0acQ0GichicGqMK8Em1RWcw/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>在介绍鉴权方法之前，我们先要了解的是：<code>什么是认证、授权、鉴权、权限控制</code>以及他们之间的关系，有了他们做铺垫，那么我们才能做到从始至终的了解透彻 ~</p><h2 id="什么是认证" tabindex="-1"><a class="header-anchor" href="#什么是认证" aria-hidden="true">#</a> 什么是认证？</h2><p><code>认证(Identification)</code> 是指根据声明者所特有的识别信息，确认声明者的身份。</p><p>白话文的意思就是：<code>你需要用身份证证明你自己是你自己</code>。</p><p>比如我们常见的认证技术：</p><ul><li><p>身份证</p></li><li><p>用户名和密码</p></li><li><p>用户手机：手机短信、手机二维码扫描、手势密码</p></li><li><p>用户的电子邮箱</p></li><li><p>用户的生物学特征：指纹、语音、眼睛虹膜</p></li><li><p>用户的大数据识别</p></li><li><p>等等</p></li></ul><h2 id="什么是授权" tabindex="-1"><a class="header-anchor" href="#什么是授权" aria-hidden="true">#</a> 什么是授权？</h2><p><code>授权(Authorization)</code>：在信息安全领域是指<code>资源所有者</code>委派<code>执行者</code>，赋予<code>执行者</code>指定范围的资源操作权限，以便对资源的相关操作。</p><p><strong>在现实生活领域例如：</strong> 银行卡（由银行派发）、门禁卡（由物业管理处派发）、钥匙（由房东派发），这些都是现实生活中授权的实现方式。</p><p><strong>在互联网领域例如：</strong> web 服务器的 session 机制、web 浏览器的 cookie 机制、颁发授权令牌（token）等都是一个授权的机制。</p><h2 id="什么是鉴权" tabindex="-1"><a class="header-anchor" href="#什么是鉴权" aria-hidden="true">#</a> 什么是鉴权？</h2><p><code>鉴权(Authentication)</code> 在信息安全领域是指<strong>对于一个声明者所声明的身份权利，对其所声明的真实性进行鉴别确认的过程</strong>。</p><p>若从授权出发，则会更加容易理解鉴权。授权和鉴权是两个上下游相匹配的关系，<strong>先授权，后鉴权</strong>。</p><p><strong>在现实生活领域：</strong> 门禁卡需要通过门禁卡识别器，银行卡需要通过银行卡识别器；</p><p><strong>在互联网领域：</strong> 校验 session/cookie/token 的合法性和有效性</p><p><code>鉴权</code> 是一个承上启下的一个环节，上游它接受授权的输出，校验其真实性后，然后获取权限（permission），这个将会为下一步的权限控制做好准备。</p><h2 id="什么是权限控制" tabindex="-1"><a class="header-anchor" href="#什么是权限控制" aria-hidden="true">#</a> 什么是权限控制？</h2><p><code>权限控制(Access/Permission Control)</code> 将可执行的操作定义为权限列表，然后判断操作是否允许/禁止</p><p>对于权限控制，可以分为两部分进行理解：一个是权限，另一个是控制。权限是抽象的逻辑概念，而控制是具体的实现方式。</p><p><strong>在现实生活领域中：</strong> 以门禁卡的权限实现为例，一个门禁卡，拥有开公司所有的门的权限；一个门禁卡，拥有管理员角色的权限，因而可以开公司所有的门。</p><p><strong>在互联网领域：</strong> 通过 web 后端服务，来控制接口访问，允许或拒绝访问请求。</p><h1 id="认证、授权、鉴权和权限控制的关系" tabindex="-1"><a class="header-anchor" href="#认证、授权、鉴权和权限控制的关系" aria-hidden="true">#</a> 认证、授权、鉴权和权限控制的关系？</h1><p>看到这里，我们应该明白了<code>认证</code>、<code>授权</code>、<code>鉴权</code>和<code>权限控制</code>这四个环节是一个<code>前后依次发生</code>、<code>上下游</code>的关系;</p><figure><img src="https://mmbiz.qpic.cn/mmbiz/mshqAkialV7Gonk6JI5LwQu1uS9fWP6JwtcbEKy2TQRYhsOUfEibzBy8MfKfeko6Tub1knfMYCNiapgswoOAVeKFw/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>需要说明的是，这四个环节在有些时候会同时发生。例如在下面的几个场景：</p><ul><li><p><strong>使用门禁卡开门：</strong> 认证、授权、鉴权、权限控制四个环节一气呵成，在瞬间同时发生</p></li><li><p><strong>用户的网站登录：</strong> 用户在使用用户名和密码进行登录时，认证和授权两个环节一同完成，而鉴权和权限控制则发生在后续的请求访问中，比如在选购物品或支付时。</p></li></ul><blockquote><p>这里提个小问题，供大家思考：<strong>认证和鉴权之间的关系？欢迎大家在评论区讨论</strong></p></blockquote><p>既然我们已经了解了他们之间的关系，那么我们应该好好讲讲关于前端鉴权有哪些？以及他们之间存在的差异点又在哪里呢？</p><h2 id="_1-http-基本鉴权" tabindex="-1"><a class="header-anchor" href="#_1-http-基本鉴权" aria-hidden="true">#</a> 1. HTTP 基本鉴权</h2><p>在 HTTP 中，<code>基本认证方案（Basic Access Authentication)</code> 是允许客户端（通常指的就是网页浏览器）在请求时，通过用户提供用户名和密码的方式，实现对用户身份的验证。</p><blockquote><p>因为几乎所有的线上网站都不会走该认证方案，所以该方案大家了解即可</p></blockquote><h3 id="_1-1-认证流程图" tabindex="-1"><a class="header-anchor" href="#_1-1-认证流程图" aria-hidden="true">#</a> 1.1 认证流程图</h3><figure><img src="https://mmbiz.qpic.cn/mmbiz/mshqAkialV7Gonk6JI5LwQu1uS9fWP6Jw63vQSNNBicf6mCN4Coza9W8rea5ia6wwetJgCVNjfzGl88icDlY3TjAxQ/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="_1-2-认证步骤解析" tabindex="-1"><a class="header-anchor" href="#_1-2-认证步骤解析" aria-hidden="true">#</a> 1.2 认证步骤解析</h3><ol><li><p><strong>客户端(如浏览器)：</strong> 向服务器请求一个<code>受限的列表数据或资源</code>，例如字段如下</p><p><code>GET /list/ HTTP/1.1  Host: www.baidu.com  Authorization: Basic aHR0cHdhdGNoOmY=</code></p></li><li><p><strong>服务器</strong>：客户端你好，这个资源在安全区 baidu.com里，是受限资源，需要基本认证；</p><p>并且向客户端返回 401 状态码（Unauthorized 未被授权的）以及附带提供了一个认证域 <code>www-Authenticate: Basic realm=”baidu.com”</code>要求进行身份验证；</p><p>其中<code>Basic</code> 就是验证的模式，而 <code>realm=&quot;baidu.com&quot;</code> 说明客户端需要输入这个安全域的用户名和密码，而不是其他域的</p><p><code>HTTP/1.1 401 Unauthorized www-Authenticate: Basic realm= &quot;baidu.com&quot;</code></p></li><li><p><strong>客户端：</strong> 服务器，我已经携带了用户名和密码给你了，你看一下；（注：如客户端是浏览器，那么此时会自动弹出一个弹窗，让用户输入用户名和密码）；</p><p>输入完用户名和密码后，则客户端将用户名及密码以 Base64 加密方式发送给服务器</p><p>传送的格式如下 (其中 Basic 内容为：<strong>用户名:密码 的 ase64 形式</strong>)：</p><p><code>GET /list/ HTTP/1.1 Authorization: Basic Ksid2FuZzp3YW5n==</code></p></li><li><p><strong>服务器：</strong> 客户端你好，我已经校验了<code>Authorization</code> 字段你的用户名和密码，是正确的，这是你要的资源。</p><p><code>HTTP/1.1 200 OK  ...</code></p></li></ol><h3 id="_1-3-优点" tabindex="-1"><a class="header-anchor" href="#_1-3-优点" aria-hidden="true">#</a> 1.3 优点</h3><p>简单，基本所有流行的浏览器都支持</p><h3 id="_1-4-缺点" tabindex="-1"><a class="header-anchor" href="#_1-4-缺点" aria-hidden="true">#</a> 1.4 缺点</h3><ol><li><strong>不安全：</strong></li></ol><ul><li><p>由于是基于 HTTP 传输，所以它在网络上几乎是裸奔的，虽然它使用了 Base64 来编码，但这个编码很容易就可以解码出来。</p></li><li><p>即使认证内容无法被解码为原始的用户名和密码也是不安全的，恶意用户可以再获取了认证内容后使用其不断的享服务器发起请求，这就是所谓的重放攻击。</p></li></ul><ol start="3"><li><strong>无法主动注销</strong>：</li></ol><ul><li>由于 HTTP 协议没有提供机制清除浏览器中的 Basic 认证信息，除非标签页或浏览器关闭、或用户清除历史记录。</li></ul><h3 id="_1-5-使用场景" tabindex="-1"><a class="header-anchor" href="#_1-5-使用场景" aria-hidden="true">#</a> 1.5 使用场景</h3><p>内部网络，或者对安全要求不是很高的网络。</p><h2 id="_2-session-cookie-鉴权" tabindex="-1"><a class="header-anchor" href="#_2-session-cookie-鉴权" aria-hidden="true">#</a> 2. Session-Cookie 鉴权</h2><p><code>Session-Cookie</code> 认证是利用服务端的 <strong>Session（会话</strong>）和 <strong>浏览器（客户端）</strong> 的 Cookie 来实现的前后端通信认证模式。</p><p>在理解这句话之前我们先简单了解下 <code>什么是 Cookie</code> 以及 <code>什么是 Session</code> ？</p><h3 id="_2-1-什么是-cookie" tabindex="-1"><a class="header-anchor" href="#_2-1-什么是-cookie" aria-hidden="true">#</a> 2.1 什么是 Cookie</h3><p>众所周知，<code>HTTP 是无状态的协议</code>（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）；</p><p>所以为了让服务器区分不同的客户端，就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态可以通过 <code>Cookie</code> 去实现。</p><p><strong>特点：</strong></p><ul><li><p>Cookie 存储在客户端，可随意篡改，不安全</p></li><li><p>有大小限制，最大为 4kb</p></li><li><p>有数量限制，一般一个浏览器对于一个网站只能存不超过 20 个 Cookie，浏览器一般只允许存放 300个 Cookie</p></li><li><p>Android 和 IOS 对 Cookie 支持性不好</p></li><li><p>Cookie 是不可跨域的，但是一级域名和二级域名是允许共享使用的（靠的是 domain）</p></li></ul><h3 id="_2-2-什么是-session" tabindex="-1"><a class="header-anchor" href="#_2-2-什么是-session" aria-hidden="true">#</a> 2.2 什么是 Session</h3><p>Session 的抽象概念是会话，是无状态协议通信过程中，为了实现中断/继续操作，将用户和服务器之间的交互进行的一种抽象；</p><p>具体来说，是服务器生成的一种 Session 结构，可以通过多种方式保存，如内存、数据库、文件等，大型网站一般有专门的 Session 服务器集群来保存用户会话；</p><p><strong>原理流程：</strong></p><ol><li><p><strong>客户端：</strong> 用户向服务器首次发送请求；</p></li><li><p><strong>服务器：</strong> 接收到数据并自动为该用户创建特定的 Session / Session ID，来标识用户并跟踪用户当前的会话过程；</p></li><li><p><strong>客户端：</strong> 浏览器收到响应获取会话信息，并且会在下一次请求时带上 Session / Session ID；</p></li><li><p><strong>服务器：</strong> 服务器提取后会与本地保存的 Session ID进行对比找到该特定用户的会话，进而获取会话状态；</p></li><li><p>至此客户端与服务器的通信变成有状态的通信；</p></li></ol><p><strong>特点：</strong></p><ul><li><p>Session 保存在服务器上；</p></li><li><p>通过服务器自带的加密协议进行；</p></li></ul><p><strong>与 Cookie 的差异：</strong></p><ul><li><p><strong>安全性：</strong> Cookie 由于保存在客户端，可随意篡改，Session 则不同存储在服务器端，无法伪造，所以 Session 的安全性更高；</p></li><li><p><strong>存取值的类型不同：</strong> Cookie 只支持字符串数据，Session 可以存任意数据类型；</p></li><li><p><strong>有效期不同：</strong> Cookie 可设置为长时间保持，Session 一般失效时间较短；</p></li><li><p><strong>存储大小不同：</strong> Cookie 保存的数据不能超过 4K；</p></li></ul><blockquote><p>看到这里可能就有同学想到了，<code>Session-Cookie</code> 是不是就是把 <code>Session</code> 存储在了客户端的 <code>Cookie</code> 中呢？</p><p><strong>Bingo</strong>，的确是这样的，我们接着往下看</p></blockquote><h3 id="_2-3-session-cookie-的认证流程图" tabindex="-1"><a class="header-anchor" href="#_2-3-session-cookie-的认证流程图" aria-hidden="true">#</a> 2.3 Session-Cookie 的认证流程图</h3><figure><img src="https://mmbiz.qpic.cn/mmbiz/mshqAkialV7Gonk6JI5LwQu1uS9fWP6Jwor6hIbFXa3Yw7glG5hC0vczIosMbjE52VKibLSL9s36pPa5XEgKicLkw/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="_2-4-session-cookie-认证步骤解析" tabindex="-1"><a class="header-anchor" href="#_2-4-session-cookie-认证步骤解析" aria-hidden="true">#</a> 2.4 Session-Cookie 认证步骤解析</h3><ol><li><p><strong>客户端：</strong> 向服务器发送登录信息用户名/密码来请求登录校验；</p></li><li><p><strong>服务器：</strong> 验证登录的信息，验证通过后自动创建 Session（将 Session 保存在内存中，也可以保存在 Redis 中），然后给这个 Session 生成一个唯一的标识字符串会话身份凭证 <code>session_id</code>(通常称为 <code>sid</code>)，并在响应头 <code>Set-Cookie</code> 中设置这个唯一标识符；</p><blockquote><p>注：可以使用签名对 <code>sid</code> 进行加密处理，服务端会根据对应的 <code>secret</code> 密钥进行解密 （非必须步骤）</p></blockquote></li><li><p><strong>客户端：</strong> 收到服务器的响应后会解析响应头，并自动将 <code>sid</code> 保存在本地 Cookie 中，浏览器在下次 HTTP 请求时请求头会自动附带上该域名下的 Cookie 信息；</p></li><li><p><strong>服务器：</strong> 接收客户端请求时会去解析请求头 Cookie 中的 <code>sid</code>，然后根据这个 <code>sid</code> 去找服务端保存的该客户端的 <code>sid</code>，然后判断该请求是否合法；</p></li></ol><h3 id="_2-5-session-cookie-的优点" tabindex="-1"><a class="header-anchor" href="#_2-5-session-cookie-的优点" aria-hidden="true">#</a> 2.5 Session-Cookie 的优点</h3><ul><li><p>Cookie 简单易用</p></li><li><p>Session 数据存储在服务端，相较于 JWT 方便进行管理，也就是当用户登录和主动注销，只需要添加删除对应的 Session 就可以了，方便管理</p></li><li><p>只需要后端操作即可，前端可以无感等进行操作；</p></li></ul><h3 id="_2-6-session-cookie-的缺点" tabindex="-1"><a class="header-anchor" href="#_2-6-session-cookie-的缺点" aria-hidden="true">#</a> 2.6 Session-Cookie 的缺点</h3><ul><li><p>依赖 Cookie，一旦用户在浏览器端禁用 Cookie，那么就 GG 思密达了；</p></li><li><p>非常不安全，Cookie 将数据暴露在浏览器中，增加了数据被盗的风险（容易被 CSRF 等攻击）；</p></li><li><p>Session 存储在服务端，增大了服务端的开销，用户量大的时候会大大降低服务器性能；</p></li><li><p>对移动端的支持性不友好；</p></li></ul><h3 id="_2-7-使用场景" tabindex="-1"><a class="header-anchor" href="#_2-7-使用场景" aria-hidden="true">#</a> 2.7 使用场景</h3><ul><li><p>一般中大型的网站都适用（除了 APP 移动端）；</p></li><li><p>由于一般的 Session 需集中存储在内存服务器上（如 Redis），这样就会增加服务器的预算，所以预算不够请谨慎选择；</p></li></ul><h3 id="_2-8-前端常用的-session-库推荐" tabindex="-1"><a class="header-anchor" href="#_2-8-前端常用的-session-库推荐" aria-hidden="true">#</a> 2.8 前端常用的 Session 库推荐</h3><ul><li><p>使用 express：express-session[1]</p></li><li><p>使用 koa：koa-session[2]</p></li></ul><h2 id="_3-token-鉴权" tabindex="-1"><a class="header-anchor" href="#_3-token-鉴权" aria-hidden="true">#</a> 3. Token 鉴权</h2><p>现在我们已经得知，<code>Session-Cookie</code> 的一些缺点，以及 Session 的维护给服务端造成很大困扰，我们必须找地方存放它，又要考虑分布式的问题，甚至要单独为了它启用一套 Redis 集群。那有没有更好的办法？</p><p>那 <code>Token</code> 就应运而生了</p><h3 id="_3-1-什么是-token-令牌" tabindex="-1"><a class="header-anchor" href="#_3-1-什么是-token-令牌" aria-hidden="true">#</a> 3.1 什么是 Token（令牌）</h3><p><code>Token</code> 是一个令牌，客户端访问服务器时，验证通过后服务端会为其签发一张令牌，之后，客户端就可以携带令牌访问服务器，服务端只需要验证令牌的有效性即可。</p><p>一句话概括；<strong>访问资源接口（API）时所需要的资源凭证</strong></p><p><strong>一般 Token 的组成：</strong></p><p><strong>uid</strong> (用户唯一的身份标识) + <strong>time</strong> (当前时间的时间戳) + <strong>sign</strong> (签名，Token 的前几位以哈希算法压缩成的一定长度的十六进制字符串)</p><p><strong>Token 的认证流程图：</strong></p><figure><img src="https://mmbiz.qpic.cn/mmbiz/mshqAkialV7Gonk6JI5LwQu1uS9fWP6JwHeYNicQibI7rwt8c4SITTFqFHJLDI5AcpRfAepctCUXTjHPpo1drgKGw/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><strong>Token 认证步骤解析：</strong></p><ol><li><p><strong>客户端：</strong> 输入用户名和密码请求登录校验；</p></li><li><p><strong>服务器：</strong> 收到请求，去验证用户名与密码；验证成功后，服务端会签发一个 Token 并把这个 Token 发送给客户端；</p></li><li><p><strong>客户端：</strong> 收到 Token 以后需要把它存储起来，web 端一般会放在 localStorage 或 Cookie 中，移动端原生 APP 一般存储在本地缓存中；</p></li><li><p><strong>客户端发送请求：</strong> 向服务端请求 API 资源的时候，将 Token 通过 HTTP 请求头 Authorization 字段或者其它方式发送给服务端；</p></li><li><p><strong>服务器：</strong> 收到请求，然后去验证客户端请求里面带着的 Token ，如果验证成功，就向客户端返回请求的数据，否则拒绝返还（401）；</p></li></ol><p><strong>Token 的优点：</strong></p><ul><li><p><strong>服务端无状态化、可扩展性好：</strong> Token 机制在服务端不需要存储会话（Session）信息，因为 Token 自身包含了其所标识用户的相关信息，这有利于在多个服务间共享用户状态</p></li><li><p><strong>支持 APP 移动端设备；</strong></p></li><li><p><strong>安全性好：</strong> 有效避免 CSRF 攻击（因为不需要 Cookie）</p></li><li><p><strong>支持跨程序调用：</strong> 因为 Cookie 是不允许跨域访问的，而 Token 则不存在这个问题</p></li></ul><p><strong>Token 的缺点：</strong></p><ul><li><p><strong>配合：</strong> 需要前后端配合处理；</p></li><li><p><strong>占带宽：</strong> 正常情况下比 <code>sid</code> 更大，消耗更多流量，挤占更多宽带</p></li><li><p><strong>性能问题：</strong> 虽说验证 Token 时不用再去访问数据库或远程服务进行权限校验，但是需要对 Token 加解密等操作，所以会更耗性能；</p></li><li><p><strong>有效期短：</strong> 为了避免 Token 被盗用，一般 Token 的有效期会设置的较短，所以就有了 <code>Refresh Token</code>；</p></li></ul><h3 id="_3-2-什么是-refresh-token-刷新-token" tabindex="-1"><a class="header-anchor" href="#_3-2-什么是-refresh-token-刷新-token" aria-hidden="true">#</a> 3.2 什么是 Refresh Token（刷新 Token）</h3><p>业务接口用来鉴权的 Token，我们称之为 <code>Access Token</code>。</p><p>为了安全，我们的 <code>Access Token</code> 有效期一般设置较短，以避免被盗用。但过短的有效期会造成 <code>Access Token</code> 经常过期，过期后怎么办呢？</p><p>一种办法是：<code>刷新 Access Token</code>，让用户重新登录获取新 Token，会很麻烦；</p><p>另外一种办法是：再来一个 Token，一个专门生成 Access Token 的 Token，我们称为 <code>Refresh Token</code>；</p><ul><li><p><strong>Access Token：</strong> 用来访问业务接口，由于有效期足够短，盗用风险小，也可以使请求方式更宽松灵活；</p></li><li><p><strong>Refresh Token：</strong> 用来获取 Access Token，有效期可以长一些，通过独立服务和严格的请求方式增加安全性；由于不常验证，也可以如前面的 Session 一样处理；</p></li></ul><p><strong>Refresh Token 的认证流程图：</strong></p><figure><img src="https://mmbiz.qpic.cn/mmbiz/mshqAkialV7Gonk6JI5LwQu1uS9fWP6JwP5l7tL4p6uouDal4BxvdM92Fiac4keInjs2tSO0pwS6k3BWxMia3rgjw/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><strong>Refresh Token 认证步骤解析：</strong></p><ol><li><p><strong>客户端：</strong> 输入用户名和密码请求登录校验；</p></li><li><p><strong>服务端：</strong> 收到请求，验证用户名与密码；验证成功后，服务端会签发一个 <code>Access Token</code> 和 <code>Refresh Token</code> 并返回给客户端；</p></li><li><p><strong>客户端：</strong> 把 <code>Access Token</code> 和 <code>Refresh Token</code> 存储在本地；</p></li><li><p><strong>客户端发送请求：</strong> 请求数据时，携带 <code>Access Token</code> 传输给服务端；</p></li><li><p><strong>服务端</strong>：</p></li></ol><ul><li><p>验证 Access Token 有效：正常返回数据</p></li><li><p>验证 Access Token 过期：拒绝请求</p></li></ul><ol start="7"><li><p><strong>客户端</strong> ( Access Token 已过期) <strong>：</strong> 则重新传输 Refresh Token 给服务端；</p></li><li><p><strong>服务端</strong> ( Access Token 已过期) <strong>：</strong> 验证 Refresh Token ，验证成功后返回新的 Access Token 给客户端；</p></li><li><p><strong>客户端：</strong> 重新携带新的 Access Token 请求接口；</p></li></ol><h3 id="_3-3-token-和-session-cookie-的区别" tabindex="-1"><a class="header-anchor" href="#_3-3-token-和-session-cookie-的区别" aria-hidden="true">#</a> 3.3 Token 和 Session-Cookie 的区别</h3><p><code>Session-Cookie</code> 和 <code>Token</code> 有很多类似的地方，但是 <code>Token</code> 更像是 <code>Session-Cookie</code> 的升级改良版。</p><ul><li><p><strong>存储地不同：</strong> Session 一般是存储在服务端；Token 是无状态的，一般由前端存储；</p></li><li><p><strong>安全性不同：</strong> Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击；</p></li><li><p><strong>支持性不同：</strong> Session-Cookie 认证需要靠浏览器的 Cookie 机制实现，如果遇到原生 NativeAPP 时这种机制就不起作用了，或是浏览器的 Cookie 存储功能被禁用，也是无法使用该认证机制实现鉴权的；而 Token 验证机制丰富了客户端类型。</p></li></ul><blockquote><p><strong>如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。</strong></p></blockquote><h2 id="_4-jwt-json-web-token-鉴权" tabindex="-1"><a class="header-anchor" href="#_4-jwt-json-web-token-鉴权" aria-hidden="true">#</a> 4. JWT（JSON Web Token）鉴权</h2><p>通过第三节，我们知道了 <code>Token</code> 的使用方式以及组成，我们不难发现，服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户基本信息，然后验证 Token 是否有效；</p><p>这样每次请求验证都要查询数据库，增加了查库带来的延迟等性能消耗；</p><p><strong>那么这时候业界常用的 <code>JWT</code> 就应运而生了！！！</strong></p><h3 id="_4-1-什么是-jwt" tabindex="-1"><a class="header-anchor" href="#_4-1-什么是-jwt" aria-hidden="true">#</a> 4.1 什么是 JWT</h3><p><code>JWT</code> 是 <code>Auth0</code> 提出的通过 <code>对 JSON 进行加密签名</code>来实现授权验证的方案；</p><p>就是登录成功后将相关用户信息组成 JSON 对象，然后对这个对象进行某种方式的<code>加密</code>，返回给客户端；客户端在下次请求时带上这个 Token；服务端再收到请求时<code>校验 token 合法性</code>，其实也就是在校验请求的合法性。</p><h3 id="_4-2-jwt-的组成" tabindex="-1"><a class="header-anchor" href="#_4-2-jwt-的组成" aria-hidden="true">#</a> 4.2 JWT 的组成</h3><p>JWT 由三部分组成：<code>Header 头部</code>、 <code>Payload 负载</code> 和 <code>Signature 签名</code></p><p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。列如 ：</p><p><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code></p><p><strong>Header 头部：</strong></p><p>在 Header 中通常包含了两部分：</p><ul><li><p>typ：代表 Token 的类型，这里使用的是 JWT 类型；</p></li><li><p>alg：使用的 Hash 算法，例如 HMAC SHA256 或 RSA.</p></li></ul><p><code>{    &quot;alg&quot;: &quot;HS256&quot;,    &quot;typ&quot;: &quot;JWT&quot;  }</code></p><p><strong>Payload 负载：</strong></p><p>它包含一些声明 Claim (实体的描述，通常是一个 User 信息，还包括一些其他的元数据) ，用来存放实际需要传递的数据，JWT 规定了7个官方字段：</p><ul><li><p>iss (issuer)：签发人</p></li><li><p>exp (expiration time)：过期时间</p></li><li><p>sub (subject)：主题</p></li><li><p>aud (audience)：受众</p></li><li><p>nbf (Not Before)：生效时间</p></li><li><p>iat (Issued At)：签发时间</p></li><li><p>jti (JWT ID)：编号</p></li></ul><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><p><code>{    &quot;sub&quot;: &quot;1234567890&quot;,    &quot;name&quot;: &quot;John Doe&quot;,    &quot;admin&quot;: true  }</code></p><p><strong>Signature 签名</strong></p><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><p><code>HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</code></p><h3 id="_4-3-jwt-的使用方式" tabindex="-1"><a class="header-anchor" href="#_4-3-jwt-的使用方式" aria-hidden="true">#</a> 4.3 JWT 的使用方式</h3><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。</p><p><code>Authorization: Bearer &lt;token&gt;</code></p><h3 id="_4-4-jwt-的认证流程图" tabindex="-1"><a class="header-anchor" href="#_4-4-jwt-的认证流程图" aria-hidden="true">#</a> 4.4 JWT 的认证流程图</h3><p>其实 JWT 的认证流程与 Token 的认证流程差不多，只是不需要再单独去查询数据库查找用户用户；简要概括如下：</p><figure><img src="https://mmbiz.qpic.cn/mmbiz/mshqAkialV7Gonk6JI5LwQu1uS9fWP6Jw3S0qlxY8UoyZt0wOMZFsDzQwq1hP0EWOaaeOw1xV7VcSg2Cn9ujGjQ/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="_4-5-jwt-的优点" tabindex="-1"><a class="header-anchor" href="#_4-5-jwt-的优点" aria-hidden="true">#</a> 4.5 JWT 的优点</h3><ul><li><p>不需要在服务端保存会话信息（RESTful API 的原则之一就是无状态），所以易于应用的扩展，即信息不保存在服务端，不会存在 Session 扩展不方便的情况；</p></li><li><p>JWT 中的 Payload 负载可以存储常用信息，用于信息交换，有效地使用 JWT，可以降低服务端查询数据库的次数</p></li></ul><h3 id="_4-6-jwt-的缺点" tabindex="-1"><a class="header-anchor" href="#_4-6-jwt-的缺点" aria-hidden="true">#</a> 4.6 JWT 的缺点</h3><ul><li><p><strong>加密问题：</strong> JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p></li><li><p><strong>到期问题：</strong> 由于服务器不保存 Session 状态，因此无法在使用过程中废止某个 Token，或者更改 Token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p></li></ul><h3 id="_4-7-前端常用的-jwt-库推荐" tabindex="-1"><a class="header-anchor" href="#_4-7-前端常用的-jwt-库推荐" aria-hidden="true">#</a> 4.7 前端常用的 JWT 库推荐</h3><ul><li><p>使用 express：express-jwt[3]</p></li><li><p>使用 koa：koa-jwt[4]</p></li></ul><h2 id="_5-单点登录-single-sign-on" tabindex="-1"><a class="header-anchor" href="#_5-单点登录-single-sign-on" aria-hidden="true">#</a> 5. 单点登录（Single Sign On）</h2><p>前面我们已经知道了，在同域下的客户端/服务端认证系统中，通过客户端携带凭证，可以维持一段时间内的登录状态。</p><p>但随着企业的发展，一个大型系统里可能包含 n 多子系统，用户在操作不同的系统时，需要多次登录，很麻烦，那么<code>单点登录（SSO)</code> 就可以很好的解决这个问题的，<code>在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。</code></p><ul><li><p>例如登录天猫，淘宝也会自动登录；</p></li><li><p>登录百度贴吧，百度网盘也会自动登录；</p></li></ul><h3 id="_5-1-同域下的-sso-主域名相同" tabindex="-1"><a class="header-anchor" href="#_5-1-同域下的-sso-主域名相同" aria-hidden="true">#</a> 5.1 同域下的 SSO（主域名相同）</h3><p>当百度网站存在两个相同主域名下的贴吧子系统 <code>tieba.baidu.com</code> 和网盘子系统 <code>pan.baidu.com</code> 时，以下为他们实现 SSO 的步骤：</p><ol><li><p><strong>客户端：</strong> 用户访问某个子系统时（例如 <code>tieba.baidu.com</code>），如果没有登录，则跳转至 SSO 认证中心提供的登录页面进行登录；</p></li><li><p><strong>服务端：</strong> 登录认证后，服务端把登录用户的信息存储于 Session 中，并且附加在响应头的 <code>Set-Cookie</code> 字段中，设置 Cookie 的 Domain 为 <code>.baidu.com</code> ；</p></li><li><p>客户端：再次发送请求时，携带主域名 Domain 下的 Cookie 给服务器，此时服务端就可以通过该 Cookie 来验证登录状态了；</p></li></ol><blockquote><p>其实我们不难发现，这就是我们上面讲的 <code>Session-Cookie 认证</code> 登录方式；但如果是不同域呢？毕竟不同域之间 Cookie 是不共享的，那怎么办？</p></blockquote><h3 id="_5-2-跨域下的-sso-主域名不同" tabindex="-1"><a class="header-anchor" href="#_5-2-跨域下的-sso-主域名不同" aria-hidden="true">#</a> 5.2 跨域下的 SSO（主域名不同）</h3><p>在我们常见的购物网站天猫 (tmall.com) 和 淘宝 (taobao.com) 中，我们只需要登录其中某一个系统，另外一个系统打开后就会默认登录，那么这是怎么做的呢？</p><p>那么就有了 <code>CAS（Central Authentication Service）中央授权服务</code>，那么我们先主要说下 <code>CAS</code> 的流程；</p><p><strong>单点登录下的 CAS 认证流程图：</strong></p><figure><img src="https://mmbiz.qpic.cn/mmbiz/mshqAkialV7Gonk6JI5LwQu1uS9fWP6JwreACYKhIJyYYfjjXQzsMMkUB32Q7ck1T9z6hHfJLRBqhoT7bXGh3Lg/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><strong>单点登录下的 CAS 认证步骤详解：</strong></p><ol><li><p><strong>客户端：</strong> 开始访问系统 A；</p></li><li><p><strong>系统 A：</strong> 发现用户未登录，重定向至 CAS 认证服务（sso.com），同时 URL 地址参数携带登录成功后回跳到系统 A 的页面链接（https://sso.com/login?redirectURL=https%3A%2F%2Fwww.taobao.com%EF%BC%89%EF%BC%9B）</p></li><li><p><strong>CAS 认证服务：</strong> 发现请求 Cookie 中没有携带登录的票据凭证（TGC），所以 CAS 认证服务判定用户处于 <code>未登录</code> 状态，重定向用户页面至 CAS 的登录界面，用户在 CAS 的登录页面上进行登录操作。</p></li><li><p><strong>客户端：</strong> 输入用户名密码进行 CAS 系统认证；</p></li><li><p><strong>CAS 认证服务：</strong> 校验用户信息，并且 <code>生成 TGC</code> 放入自己的 Session 中，同时以 Set-Cookie 形式写入 Domain 为 <code>sso.com</code> 的域下 ；同时生成一个 <code>授权令牌 ST (Service Ticket)</code> ，然后重定向至系统 A 的地址，重定向的地址中包含生成的 ST（重定向地址：https://www.taobao.com?token=ST-345678%EF%BC%89）</p></li><li><p><strong>系统 A：</strong> 拿着 ST 向 CAS 认证服务发送请求，CAS 认证服务验证票据 (ST) 的有效性。验证成功后，系统 A 知道用户已经在 CAS 登录了（其中的 ST 可以保存到 Cookie 或者本地中），系统 A 服务器使用该票据 (ST) 创建与用户的会话，称为局部会话，返回受保护资源；</p></li></ol><blockquote><p>到这里客户端就可以跟系统 A 愉快的交往啦 ~</p></blockquote><p><strong>7.客<strong><strong>户端</strong></strong>：</strong> 开始访问系统 B；</p><p><strong>8.<strong><strong>系统 B</strong></strong>：</strong> 发现用户未登录，重定向至 SSO 认证服务，并将自己的地址作为参数传递，并附上在 sso.com 域下的 cookie 值是第五步生成的 TGC；</p><p><strong>9. CAS 认证服务：</strong> CAS 认证服务中心发现用户已登录，跳转回系统 B 的地址，并附上票据 (ST) ;</p><p><strong>10.系统 B：</strong> 拿到票据 (ST)，去 CAS 认证服务验证票据 (ST) 的有效性。验证成功后，客户端也可以跟系统 B 交往了 ~</p><blockquote><p>(PS：脚踏两只船，感觉有点渣呀 ~)</p></blockquote><p><strong>单点登录下需要注意的点：</strong></p><ul><li><p>如图中流程所示，我们发现 <code>CAS 认证服务</code> 在签发的 <code>授权令牌 ST</code> 后，直接重定向，这样其实是比较容易容易被窃取，那么我们需要在系统 A 或者系统 B 在向 CAS 验证成功 (如图中的第 14 步和第 11 步) 后，再生成另一个新的验证 Token 返回给客户端保存；</p></li><li><p>CAS 一般提供四个接口：</p></li><li><p><code>/login</code>：登录接口，用于登录到中央授权服务</p></li><li><p><code>/logout</code>：登出接口，用于从中央授权服务中登出</p></li><li><p><code>/validate</code>：用于验证用户是否登录中央授权服务</p></li><li><p><code>/serviceValidate</code>：用于让各个 Service 验证用户是否登录中央授权服务</p></li><li><p>CAS 生成的票据：</p></li><li><p><strong>TGT（Ticket Grangting Ticket）</strong> ：TGT 是 CAS 为用户签发的 <code>登录票据</code>，拥有了 TGT，用户就可以证明自己在 CAS 成功登录过。</p></li><li><p><strong>TGC：Ticket Granting Cookie：</strong> CAS Server 生成TGT放入自己的 Session 中，而 TGC 就是这个 Session 的唯一标识（SessionId），以 Cookie 形式放到浏览器端，是 CAS Server 用来明确用户身份的凭证。</p></li><li><p><strong>ST（Service Ticket）</strong> ：ST 是 CAS 为用户签发的访问某个 Service 的票据。</p></li></ul><h2 id="_6-oauth-2-0" tabindex="-1"><a class="header-anchor" href="#_6-oauth-2-0" aria-hidden="true">#</a> 6. OAuth 2.0</h2><p>在我们实际浏览网站的时候，当我们登录的时候除了输入当前网站的账号密码外，我们还发现可以通过第三方的 QQ 或者 微信登录，那么这又是如何做到了呢，这就要谈到 <strong>OAuth</strong> 了。</p><blockquote><p>OAuth 协议又有 1.0 和 2.0 两个版本，2.0 版整个授权验证流程更简单更安全，也是目前最主要的用户身份验证和授权方式。</p></blockquote><h3 id="_6-1-什么是-oauth-2-0" tabindex="-1"><a class="header-anchor" href="#_6-1-什么是-oauth-2-0" aria-hidden="true">#</a> 6.1 什么是 OAuth 2.0？</h3><p><strong>OAuth</strong> 是一个开放标准，允许用户授权第三方网站 (CSDN、思否等) 访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站；</p><p>常见的提供 OAuth 认证服务的厂商：<code>支付宝、QQ、微信、微博</code></p><p><strong>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（Token），用来代替密码，供第三方应用使用。</strong></p><p><strong>令牌与密码的差异：</strong></p><p><code>令牌（Token）</code> 与 <code>密码（Password）</code> 的作用是一样的，都可以进入系统，但是有三点差异。</p><ol><li><p><strong>令牌是短期的，到期会自动失效：</strong> 用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p></li><li><p><strong>令牌可以被数据所有者撤销，会立即失效。</strong></p></li><li><p><strong>令牌有权限范围（scope）：</strong> 对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p></li></ol><p>OAuth 2.0 对于如何颁发令牌的细节，规定得非常详细。具体来说，一共分成<strong>四种授权</strong>模式 <strong>（Authorization Grant）</strong> ，适用于不同的互联网场景。</p><p>无论哪个模式都拥有三个必要角色：<code>客户端</code>、<code>授权服务器</code>、<code>资源服务器</code>，有的还有<code>用户（资源拥有者）</code>，下面简单介绍下四种授权模式。</p><h3 id="_6-2-授权码模式" tabindex="-1"><a class="header-anchor" href="#_6-2-授权码模式" aria-hidden="true">#</a> 6.2 授权码模式</h3><p><code>授权码（Authorization Code Grant)</code> 方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</p><p>这种方式是最常用的流程，安全性也最高，它适用于那些<strong>有后端服务</strong>的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p><p>一句话概括：<code>客户端换取授权码，客户端使用授权码换token，客户端使用token访问资源</code></p><h4 id="授权码模式的步骤详解" tabindex="-1"><a class="header-anchor" href="#授权码模式的步骤详解" aria-hidden="true">#</a> 授权码模式的步骤详解</h4><ol><li><p><strong>客户端：</strong></p><p>打开网站 A，点击登录按钮，请求 A 服务，A 服务重定向 (重定向地址如下) 至授权服务器 (如QQ、微信授权服务)。</p><p><code>https://qq.com/oauth/authorize? response_type=code&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read</code></p><p>上面 URL 中，<code>response_type</code> 参数表示要求返回授权码（<code>code</code>），<code>client_id</code> 参数让 B 知道是谁在请求，<code>redirect_uri</code> 参数是 B 接受或拒绝请求后的跳转网址，<code>scope</code> 参数表示要求的授权范围（这里是只读）</p><figure><img src="https://mmbiz.qpic.cn/mmbiz/mshqAkialV7Gonk6JI5LwQu1uS9fWP6JwITHqTp6smaklsGcUI3yoxMOpF99XtGRToWa38jQtE6XDVOazqlN5yA/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure></li><li><p><strong>授权服务器：</strong></p><p><code>授权服务网站</code> 会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时<code>授权服务网站</code> 就会跳回 <code>redirect_uri</code> 参数指定的网址。跳转时，会传回一个授权码，就像下面这样。</p><p><code>https://a.com/callback?code=AUTHORIZATION_CODE </code></p><p>上面 URL 中，<code>code</code> 参数就是授权码。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz/mshqAkialV7Gonk6JI5LwQu1uS9fWP6Jw5BTClfjXG6wkG5KicJZug9iaWlyxTXr80f4J97hIYPxTuxHs4zMeTN0Q/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure></li><li><p><strong>网站 A 服务器：</strong></p><p>拿到授权码以后，就可以向 <code>授权服务器 (qq.com)</code> 请求令牌，请求地址如下：</p><p><code>https://qq.com/oauth/token? client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; grant_type=authorization_code&amp; code=AUTHORIZATION_CODE&amp; redirect_uri=CALLBACK_URL</code></p><p>上面 URL 中，<code>client_id</code> 参数和 <code>client_secret</code> 参数用来让授权服务器 确认 A 的身份（<code>client_secret</code> 参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码，<code>code</code> 参数是上一步拿到的授权码，<code>redirect_uri</code> 参数是令牌颁发后的回调网址。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz/mshqAkialV7Gonk6JI5LwQu1uS9fWP6JwxcxOKWWTSRo3sNjIMwAH6utkbC3mo3fDQUyccMLCDADXH4RCAyqhCg/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure></li><li><p><strong>授权服务器：</strong></p><p>收到请求以后，验证通过，就会颁发令牌。具体做法是向 <code>redirect_uri</code> 指定的网址，发送一段 JSON 数据。</p><p><code>{        &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,    &quot;token_type&quot;:&quot;bearer&quot;,    &quot;expires_in&quot;:2592000,    &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,    &quot;scope&quot;:&quot;read&quot;,    &quot;uid&quot;:100101,    &quot;info&quot;:{...}  }</code></p><p>上面 JSON 数据中，<code>access_token</code> 字段就是令牌，A 网站在后端拿到了，然后返回给客户端即可。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz/mshqAkialV7Gonk6JI5LwQu1uS9fWP6JwRvFbGAawXKYeJv4BE8XqibGmHF9iaWNUHW3C5Dun679V195pCPUBqEUw/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure></li></ol><h3 id="_6-3-隐藏式模式-implicit-grant" tabindex="-1"><a class="header-anchor" href="#_6-3-隐藏式模式-implicit-grant" aria-hidden="true">#</a> 6.3 隐藏式模式（Implicit Grant）</h3><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。<strong>OAuth2.0 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）&quot;隐藏式&quot;（implicit）。</strong></p><p>一句话概括：<code>客户端让用户登录授权服务器换token，客户端使用token访问资源</code>。</p><h4 id="隐藏式模式的步骤详解" tabindex="-1"><a class="header-anchor" href="#隐藏式模式的步骤详解" aria-hidden="true">#</a> 隐藏式模式的步骤详解</h4><ol><li><p><strong>客户端：</strong></p><p>打开网站 A，A 网站提供一个链接，要求用户跳转到 <code>授权服务器</code>，授权用户数据给 A 网站使用。如下链接：</p><p><code>https://qq.com/oauth/authorize? response_type=token&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read</code></p><p>上面 URL 中，<code>response_type</code>参数为<code>token</code>，表示要求直接返回令牌。</p></li><li><p><strong>授权服务器：</strong></p><p>用户跳转到授权服务器，登录后同意给予 A 网站授权。这时，授权服务器就会跳回<code>redirect_uri</code> 参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</p><p><code>https://a.com/callback#token=ACCESS_TOKEN</code></p><p>上面 URL 中，<code>token</code>参数就是令牌，A 网站因此直接在前端拿到令牌。</p><figure><img src="https://mmbiz.qpic.cn/mmbiz/mshqAkialV7Gonk6JI5LwQu1uS9fWP6JwU3Wy4dmvW5GY9ZXYLyW3C6ACQKchDnhxD0kTDTLJ81LQadkluviag0A/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure></li></ol><blockquote><p>注意：</p><ol><li><p>令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在&quot;中间人攻击&quot;的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p></li><li><p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p></li></ol></blockquote><h3 id="_6-4-用户名密码式模式-password-credentials-grant" tabindex="-1"><a class="header-anchor" href="#_6-4-用户名密码式模式-password-credentials-grant" aria-hidden="true">#</a> 6.4 用户名密码式模式（Password Credentials Grant）</h3><p>如果你高度信任某个应用，OAuth 2.0 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为&quot;密码式&quot;（password）。</p><p><strong>一句话概括：用户在客户端提交账号密码换token，客户端使用token访问资源。</strong></p><h3 id="密码式模式的步骤详解" tabindex="-1"><a class="header-anchor" href="#密码式模式的步骤详解" aria-hidden="true">#</a> 密码式模式的步骤详解</h3><ol><li><p><strong>客户端：</strong></p><p>A 网站要求用户提供 <code>授权服务器(qq.com)</code> 的用户名和密码。拿到以后，A 就直接向 <code>授权服务器</code> 请求令牌。</p><p><code>https://oauth.b.com/token? grant_type=password&amp; username=USERNAME&amp; password=PASSWORD&amp; client_id=CLIENT_ID</code></p><p>上面 URL 中，<code>grant_type</code>参数是授权方式，这里的<code>password</code>表示&quot;密码式&quot;，<code>username</code>和<code>password</code>是 <code>授权服务器</code> 的用户名和密码。</p></li><li><p><strong>授权服务器：</strong></p><p><code>授权服务器</code> 验证身份通过后，直接给出令牌。</p><p>注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 网站因此拿到令牌。</p></li></ol><blockquote><p>这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p></blockquote><h3 id="_6-5-客户端模式-client-credentials-grant" tabindex="-1"><a class="header-anchor" href="#_6-5-客户端模式-client-credentials-grant" aria-hidden="true">#</a> 6.5 客户端模式（Client Credentials Grant）</h3><p>客户端模式指客户端以自己的名义，而不是以用户的名义，向<code>授权服务器</code> 进行认证。</p><p>主要适用于没有前端的命令行应用。</p><p>一句话概括：<code>客户端使用自己的标识换token，客户端使用token访问资源</code>。</p><h4 id="客户端模式的步骤详解" tabindex="-1"><a class="header-anchor" href="#客户端模式的步骤详解" aria-hidden="true">#</a> 客户端模式的步骤详解</h4><ol><li><p>客户端：</p><p>客户端向<code>授权服务器</code> 进行身份认证，并要求一个访问令牌。请求链接地址：</p><p><code>https://oauth.b.com/token? grant_type=client_credentials&amp; client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET</code></p><p>上面 URL 中，<code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式，<code>client_id</code>和<code>client_secret</code>用来让<code>授权服务器</code> 确认 A 的身份。</p></li><li><p>授权服务器：</p><p><code>授权服务器</code> 验证通过以后，直接返回令牌。</p></li></ol><blockquote><p>注意：这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p></blockquote><h3 id="_6-6-授权模式选型" tabindex="-1"><a class="header-anchor" href="#_6-6-授权模式选型" aria-hidden="true">#</a> 6.6 授权模式选型</h3><h4 id="按授权需要的多端情况" tabindex="-1"><a class="header-anchor" href="#按授权需要的多端情况" aria-hidden="true">#</a> 按授权需要的多端情况：</h4><p>模式</p><p>需要前端</p><p>需要后端</p><p>需要用户响应</p><p>需要客户端密钥</p><p>授权码模式 Authorization Code</p><p>✅</p><p>✅</p><p>✅</p><p>✅</p><p>隐式授权模式 Implicit Grant</p><p>✅</p><p>❌</p><p>✅</p><p>❌</p><p>密码授权模式 Password Grant</p><p>✅</p><p>✅</p><p>✅</p><p>✅</p><p>客户端授权模式 Client Credentials</p><p>❌</p><p>✅</p><p>❌</p><p>✅</p><h4 id="按照客户端类型与访问令牌所有者分类" tabindex="-1"><a class="header-anchor" href="#按照客户端类型与访问令牌所有者分类" aria-hidden="true">#</a> 按照客户端类型与访问令牌所有者分类：</h4><figure><img src="https://mmbiz.qpic.cn/mmbiz/mshqAkialV7Gonk6JI5LwQu1uS9fWP6JwhGD0CrW2hrNtrajOulmoBPbVyJ89zZUj6EcWExEicd2ibz3pvfqsa5Ug/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><blockquote><p>上述主要比较浅显的讲解了 OAuth2.0 的基本逻辑，如若想详细深入的了解，可查看官方文档 OAuth[5] 或 RFC 6749[6]；亦可查看 OAuth 2.0 概念及授权流程梳理[7] 做对比</p></blockquote><h2 id="_7-联合登录和信任登录" tabindex="-1"><a class="header-anchor" href="#_7-联合登录和信任登录" aria-hidden="true">#</a> 7. 联合登录和信任登录</h2><h3 id="_7-1-什么是联合登陆" tabindex="-1"><a class="header-anchor" href="#_7-1-什么是联合登陆" aria-hidden="true">#</a> 7.1 什么是联合登陆</h3><p><code>联合登录</code> 指同时包含多种凭证校验的登录服务，同时，也可以理解为使用第三方凭证进行校验的登录服务。</p><p><strong>通俗点讲：</strong> 对于两个网站 A 和 B，在登录 A 网站的时候用 B 网站的帐号密码，就是联合登录，或者登录 B 网站的时候使用 A 网站的帐号密码，也是联合登录。</p><p>这样的概念其实与上面所讲的 OAuth2.0 的 <code>用户名密码式模式</code> 认证方式类似。</p><p>最经典的莫过于 APP 内嵌 H5 的使用场景，当用户从 APP 进入内嵌的 H5 时，我们希望 APP 内已登录的用户能够访问到 H5 内受限的资源，而未登录的用户则需要登录后访问。</p><p>这里思路主要有两种，一种是原生跳转内嵌 H5 页面时，将登录态 Token 附加在 URL 参数上，另一种则是内嵌 H5 主动通过与原生客户端制定的协议获取应用内的登录状态。</p><h3 id="_7-2-什么是信任登录" tabindex="-1"><a class="header-anchor" href="#_7-2-什么是信任登录" aria-hidden="true">#</a> 7.2 什么是信任登录</h3><p><code>信任登录</code> 是指所有不需要用户主动参与的登录，例如建立在私有设备与用户之间的绑定关系，凭证就是私有设备的信息，此时不需要用户再提供额外的凭证。信任登录又指用第三方比较成熟的用户库来校验凭证，并登录当前访问的网站。</p><p><strong>通俗点讲：</strong> 在 A 网站有登录状态的时候，可以直接跳转到 B 网站而不用登录，就是 <code>信任登录</code>。</p><p>目前比较常见的第三方信任登录帐号如：QQ 号淘宝帐号、支付宝帐号、微博帐号等。</p><p>我们不难发现 OAtuth 2.0 其实就是信任登录的缩影，因为正是有了 OAuth，我们的信任登录才得以实现。</p><h2 id="_8-唯一登录" tabindex="-1"><a class="header-anchor" href="#_8-唯一登录" aria-hidden="true">#</a> 8. 唯一登录</h2><p>— 假设现在产品经理提一个需求：<strong>我想要实现用户只能在一个设备上登录，禁止用户重复登录；</strong></p><p>— 身为优秀的程序员的我们当然是满足他啦 ！！</p><h3 id="_8-1-什么是唯一登录" tabindex="-1"><a class="header-anchor" href="#_8-1-什么是唯一登录" aria-hidden="true">#</a> 8.1 什么是唯一登录</h3><p>唯一登录，指的是<strong>禁止多人同时登录同一账号，后者的登录行为，会导致前者掉线。</strong></p><p><strong>通俗点讲就是</strong>：A 账号在 A 电脑上登录后，A 账号此时又用 B 电脑再次登录，则 A 电脑请求页面时，提示“重新登录”的信息，并跳转到登录页面</p><h3 id="_8-2-唯一登录流程图" tabindex="-1"><a class="header-anchor" href="#_8-2-唯一登录流程图" aria-hidden="true">#</a> 8.2 唯一登录流程图</h3><figure><img src="https://mmbiz.qpic.cn/mmbiz/mshqAkialV7Gonk6JI5LwQu1uS9fWP6JwtEwialqPibu0UTrerwyjI6C4RicgxkqAM1Fbz3B2lURLJpCdSUoth1VibQ/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="_8-3-唯一登录步骤详解" tabindex="-1"><a class="header-anchor" href="#_8-3-唯一登录步骤详解" aria-hidden="true">#</a> 8.3 唯一登录步骤详解</h3><p><strong>用户在客户端 A 操作：</strong></p><ol><li><p>输入账号请求登录接口；</p></li><li><p>后端生成对应 Token 并且返回给客户端 A，并且在服务端保存一个登录状态；</p></li><li><p>客户端A 保存 Token，并且每次请求都在 header 头中携带对应的 Token；</p></li></ol><p><strong>用户在客户端 B 操作：</strong></p><p>突然用户在客户端 B 上开始登录操作，我们会发现，步骤和在客户端A上面的操作几乎是一致的；</p><p>只是后端在生成新的 Token 时，要先验证登录状态，然后再生成对应新的 Token；</p><h2 id="_9-扫码登录" tabindex="-1"><a class="header-anchor" href="#_9-扫码登录" aria-hidden="true">#</a> 9. 扫码登录</h2><h3 id="_9-1-什么是扫码登录" tabindex="-1"><a class="header-anchor" href="#_9-1-什么是扫码登录" aria-hidden="true">#</a> 9.1 什么是扫码登录</h3><p>扫码登录通常见于移动端 APP 中，很多 PC 端的网站都提供了扫码登录的功能，无需在网页上输入任何账号和密码，只需要让移动端 APP (如微信、淘宝、QQ等等) 中已登录用户主动扫描 <code>二维码</code> ，再确认登录，以使 PC 端的同款应用得以快速登录的方式就是 <code>扫码登录</code> 。</p><h3 id="_9-2-什么是二维码" tabindex="-1"><a class="header-anchor" href="#_9-2-什么是二维码" aria-hidden="true">#</a> 9.2 什么是二维码</h3><p><code>二维码</code> 又称二维条码，常见的二维码为 QR Code，QR 全称 Quick Response，是一个近几年来移动设备上超流行的一种编码方式，它比传统的Bar Code条形码能存更多的信息，也能表示更多的数据类型。</p><p>通过上面所述，我们不难发现，扫码登录需要三端 (<code>PC端</code>、<code>手机端</code>、<code>服务端</code>) 来进行配合才能达到登录成功的效果；</p><h3 id="_9-3-扫码登录的认证流程图" tabindex="-1"><a class="header-anchor" href="#_9-3-扫码登录的认证流程图" aria-hidden="true">#</a> 9.3 扫码登录的认证流程图</h3><figure><img src="https://mmbiz.qpic.cn/mmbiz/mshqAkialV7Gonk6JI5LwQu1uS9fWP6Jwtf6BT5s8WlUvus7PzRbFv4XmkvEV3yMgRyHF9FfnNWiaSRHiawfCHgEA/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="_9-4-扫码登录的步骤详解-待扫码阶段、待确认阶段、已确认阶段" tabindex="-1"><a class="header-anchor" href="#_9-4-扫码登录的步骤详解-待扫码阶段、待确认阶段、已确认阶段" aria-hidden="true">#</a> 9.4 扫码登录的步骤详解 (待扫码阶段、待确认阶段、已确认阶段)</h3><p><strong>待扫码阶段：</strong></p><ol><li><p><strong>PC端：</strong></p><p>打开某个网站 (如taobao.com) 或者某个 APP (如微信) 的扫码登录入口；就会携带 PC 端的设备信息向服务端发送一个获取二维码的请求；</p></li><li><p><strong>服务端：</strong></p><p>服务器收到请求后，随机生成一个 UUID 作为二维码 ID，并将 UUID 与 <code>PC 端的设备信息</code> 关联起来存储在 Redis 服务器中，然后返回给 PC 端；同时设置一个过期时间，在过期后，用户登录二维码需要进行刷新重新获取。</p></li><li><p><strong>PC 端：</strong></p><p>收到二维码 ID 之后，将二维码 ID 以 <code>二维码的形式</code> 展示，等待移动端扫码。并且此时的 PC 端开始轮询查询二维码状态，直到登录成功。</p><p>如果移动端未扫描，那么一段时间后二维码会自动失效。</p></li></ol><p><strong>已扫码待确认阶段：</strong></p><ol><li><p><strong>手机端：</strong></p><p>打开手机端对应<strong>已登录</strong>的 APP (微信或淘宝等)，开始扫描识别 PC 端展示的二维码；</p><p>移动端扫描二维码后，会自动获取到二维码 ID，并将移动端登录的信息凭证（Token）和二维码 ID 作为参数发送给服务端，此时手机必须是已登录（使用扫描登录的前提是移动端的应用为已登录状态，这样才可以共享登录态）。</p></li><li><p><strong>服务端：</strong></p><p>收到手机端发来的请求后，会将 <code>Token 与二维码 ID</code> 关联，为什么需要关联呢？因为，当我们在使用微信时，移动端退出时，PC 端也应该随之退出登录，这个关联就起到这个作用。然后会生成一个临时 Token，这个 Token 会返回给移动端，一次性 Token 用作确认时的凭证。</p></li></ol><p><strong>已确认阶段：</strong></p><ol><li><p><strong>手机端：</strong></p><p>收到确认信息后，点击确认按钮，移动端携带上一步中获取的 <code>临时 Token</code> 发送给服务端校验；</p></li><li><p><strong>服务端：</strong></p><p>服务端校验完成后，会更新二维码状态，并且给 PC 端生成一个 <code>正式的 Token</code>，后续 PC 端就是持有这个 Token 访问服务端。</p></li><li><p><strong>PC端：</strong></p><p>轮询到二维码状态为已登录状态，并且会获取到了生成的 Token，完成登录，后续访问都基于 Token 完成。</p></li></ol><h2 id="_10-一键登录-适用于原生app" tabindex="-1"><a class="header-anchor" href="#_10-一键登录-适用于原生app" aria-hidden="true">#</a> 10. 一键登录（适用于原生APP）</h2><h3 id="_10-1-账号密码登录" tabindex="-1"><a class="header-anchor" href="#_10-1-账号密码登录" aria-hidden="true">#</a> 10.1 账号密码登录</h3><p>大家都知道，最传统的登录方式就是使用<strong>账号加密码登录</strong>，简单粗暴，一般也不会出现什么问题；</p><p><strong>缺点：</strong></p><ol><li><p>但这种方式要求用户要记住自己的账号和密码，也就是有一个记忆成本。用户为了降低记忆成本，很可能会在不同平台使用同一套账号密码。从安全角度考虑，一旦某个平台的账号密码泄露了，会连累到该用户使用的其他平台。</p></li><li><p>另外，由于账号和个人身份无关，意味着同一个用户可以注册多个不同的账号，也就是可能会有恶意注册的情况发生。</p></li></ol><p><strong>直到手机卡的强制实名制才得以解决！</strong></p><h3 id="_10-2-手机号验证码登录" tabindex="-1"><a class="header-anchor" href="#_10-2-手机号验证码登录" aria-hidden="true">#</a> 10.2 手机号验证码登录</h3><p>随着无线互联的发展以及手机卡实名制的推广，手机号俨然已成为特别的身份证明，与账号密码相比，手机号可以更好地验证用户的身份，防止恶意注册。</p><p>但是手机号注册还是需要一系列繁琐的操作：输入手机号、等待短信验证码、输入验证码、点击登录。整个流程少说二十秒，而且如果收不到短信，也就登录补了，这类问题有可能导致潜在的用户流失。</p><p>从安全角度考虑，还存在验证码泄漏的风险。如果有人知道了你的手机号，并且窃取到了验证码，那他也能登录你的账号了。</p><p><strong>所以就有了一键登录操作！</strong></p><h3 id="_10-3-什么是一键登录" tabindex="-1"><a class="header-anchor" href="#_10-3-什么是一键登录" aria-hidden="true">#</a> 10.3 什么是一键登录</h3><p>我们想一下，为什么我们需要验证码？验证码的作用就是确定这个手机号是你的，那除了使用短信，是否还有别的方式对手机号进行认证？</p><p>于是，就有了咱们的主角一键登录。</p><p>短信验证码的作用就是证明当前操作页面的用户与输入手机号的用户为相同的人，那么实际上只要我们能够获取到当前手机使用的手机卡号，直接使用这个号码进行登录，不需要额外的操作，这就是<strong>一键登录</strong>。</p><p>一键登录能不能做，取决于运营商是否开放相关服务；随着运营商开放了相关的服务，我们现在已经能够接入运营商提供的 SDK 并付费使用相关的服务。</p><p><strong>一键登录流程图：</strong></p><figure><img src="https://mmbiz.qpic.cn/mmbiz/mshqAkialV7Gonk6JI5LwQu1uS9fWP6Jw7KGuJb9XytYRGWiaGMZH5jQOVRUOsuFzPiaBh85S1L9stkYhAISFvlQQ/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p><strong>一键登录步骤详解：</strong></p><ol><li><p><strong>SDK 初始化：</strong> 调用 SDK 方法，传入平台配置的 AppKey 和 AppSecret</p></li><li><p><strong>唤起授权页：</strong> 调用 SDK 唤起授权接口，SDK 会先向运营商发起获取手机号掩码的请求，请求成功后跳到授权页。授权页会显示手机号掩码以及运营商协议给用户确认。</p></li><li><p><strong>同意授权并登录：</strong> 用户同意相关协议，点击授权页面的登录按钮，SDK 会请求本次取号的 Token，请求成功后将 Token 返回给客户端</p></li><li><p><strong>取号：</strong> 将获取到的 Token 发送到自己的服务器，由服务端携带 Token 调用运营商一键登录的接口，调用成功就返回手机号码。服务端用手机号进行登录或注册操作，返回操作结果给客户端，完成一键登录。</p></li></ol><p><strong>三大运营商开放平台：</strong></p><ul><li><p>移动 - 互联网能力开放平台[8]</p></li><li><p>电信 - 天翼账号开放平台[9]</p></li><li><p>联通 - WO+ 开放平台[10]</p><p>由于国内三大运营商各自有独立的 SDK，所以会导致兼容方面的工作会特别繁琐。如果要采用一键登录的方案，不妨采用第三方提供了号码认证服务，下列几家供应商都拥有手机号码认证能力：</p></li><li><p>阿里 - 号码认证服务[11]</p></li><li><p>创蓝 - 闪验[12]</p></li><li><p>极光 - 极光认证[13]</p></li><li><p>mob - 秒验[14]</p></li></ul><p><strong>注意：</strong></p><p>在认证过程中，需要用户打开蜂窝网络，如果手机设备没有插入 SIM 卡、或者关闭蜂窝网络的情况下，是无法完成认证的。所以就算接入一键登录，还是要兼容传统的登录方式，允许用户在失败的情况下，仍能正常完成登录流程。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>在学习了解上面的 10 种鉴权方法后，我们简单概括一下</p><ul><li><p><code>HTTP 基本认证</code>适用于内部网络，或者对安全要求不是很高的网络；</p></li><li><p><code>Session-Cookie</code> 适用于一般中大型的网站（移动端 APP 除外）；</p></li><li><p><code>Token</code> 和 <code>JWT</code> 都适用于市面上大部分的企业型网站，JWT 效能会优于 Token；</p></li><li><p><code>单点登录</code> 适用于子系统较多的大型企业网站；</p></li><li><p><code>OAuth 2.0</code>适用于需要快速注册用户型的网站；</p></li><li><p><code>扫码登录</code> 适用于已完成部署了三端的企业；</p></li><li><p><code>一键登录</code> 适用于原生 APP；</p></li></ul>',308),a=[t];function r(s,c){return e(),i("div",null,a)}const h=o(n,[["render",r],["__file","前后端鉴权.html.vue"]]);export{h as default};
