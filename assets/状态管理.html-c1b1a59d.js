const e=JSON.parse('{"key":"v-06753a5c","path":"/Tech/Front-end/03_VUE/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html","title":"","lang":"en-US","frontmatter":{"description":"一个完整的实例，页面或者单元，由以下三个部分组成： 状态：即数据 视图：页面样式，数据在前端的映射 交互：状态根据用户在视图中的操作而做出改变的可能方式，即方法 在一个独立的组件中，这三者彼此配合和依赖，但是我们会出现更加复杂的场景，比如： 多个组件视图依赖同一个数据状态 来自不同视图的交互需要修改同一份状态 根据以上的需求，我们将组件中共享的状态都抽出来，放在一个全局的地方来管理，我们的组件树就成了一个大的“视图”，在任意位置上的组件都可以访问其中的状态或者触发动作","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/Tech/Front-end/03_VUE/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"Blog Demo"}],["meta",{"property":"og:description","content":"一个完整的实例，页面或者单元，由以下三个部分组成： 状态：即数据 视图：页面样式，数据在前端的映射 交互：状态根据用户在视图中的操作而做出改变的可能方式，即方法 在一个独立的组件中，这三者彼此配合和依赖，但是我们会出现更加复杂的场景，比如： 多个组件视图依赖同一个数据状态 来自不同视图的交互需要修改同一份状态 根据以上的需求，我们将组件中共享的状态都抽出来，放在一个全局的地方来管理，我们的组件树就成了一个大的“视图”，在任意位置上的组件都可以访问其中的状态或者触发动作"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"article:author","content":"Mr.Jacob"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Jacob\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":3,"title":"管理方式之store模式","slug":"管理方式之store模式","link":"#管理方式之store模式","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.62,"words":486},"filePathRelative":"Tech/Front-end/03_VUE/状态管理.md","excerpt":"<p>一个完整的实例，页面或者单元，由以下三个部分组成：</p>\\n<ol>\\n<li>状态：即数据</li>\\n<li>视图：页面样式，数据在前端的映射</li>\\n<li>交互：状态根据用户在视图中的操作而做出改变的可能方式，即方法</li>\\n</ol>\\n<p>在一个独立的组件中，这三者彼此配合和依赖，但是我们会出现更加复杂的场景，比如：</p>\\n<ul>\\n<li>多个组件视图依赖同一个数据状态</li>\\n<li>来自不同视图的交互需要修改同一份状态</li>\\n</ul>\\n<p>根据以上的需求，我们将组件中共享的状态都抽出来，放在一个全局的地方来管理，我们的组件树就成了一个大的“视图”，在任意位置上的组件都可以访问其中的状态或者触发动作</p>","autoDesc":true}');export{e as data};
