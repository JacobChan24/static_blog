import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as r,c,f as l}from"./app-9e438faa.js";const o={},s=l(`<p>node js提供了很多监听器，可以用于不同的监听场景</p><h3 id="server对象监听器" tabindex="-1"><a class="header-anchor" href="#server对象监听器" aria-hidden="true">#</a> server对象监听器</h3><ol><li><p>&#39;request&#39;：当有HTTP请求到达服务器时触发该事件。可以使用<code>server.on(&#39;request&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数会被传入两个参数：一个request对象和一个response对象。</p></li><li><p>&#39;connection&#39;：当有新的TCP连接建立时触发该事件。可以使用<code>server.on(&#39;connection&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数会被传入一个socket对象，它表示一个TCP连接。</p></li><li><p>&#39;close&#39;：当服务器关闭时触发该事件。可以使用<code>server.on(&#39;close&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数不需要传入任何参数。</p></li><li><p>&#39;listening&#39;：当服务器开始监听端口时触发该事件。可以使用<code>server.on(&#39;listening&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数不需要传入任何参数。</p></li></ol><p>下面是一个使用监听器的例子：监听请求事件</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const http = require(&#39;http&#39;);

const server = http.createServer((req, res) =&gt; {
  res.statusCode = 200;
  res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;);
  res.end(&#39;Hello World\\n&#39;);
});

server.on(&#39;request&#39;, (req, res) =&gt; {
  console.log(\`Received request for \${req.url}\`);
});

server.listen(3000, () =&gt; {
  console.log(\`Server running at http://localhost:3000/\`);
});

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是其他一些server对象可以监听的事件：</p><ol><li><p>&#39;error&#39;：当服务器发生错误时触发该事件。可以使用<code>server.on(&#39;error&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数会被传入一个Error对象，它表示发生的错误。</p></li><li><p>&#39;upgrade&#39;：当有HTTP Upgrade请求到达服务器时触发该事件。可以使用<code>server.on(&#39;upgrade&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数会被传入三个参数：一个request对象、一个socket对象和一个head对象。</p></li><li><p>&#39;clientError&#39;：当客户端发生错误时触发该事件。可以使用<code>server.on(&#39;clientError&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数会被传入一个Error对象，它表示发生的错误。</p></li></ol><p>除了上述事件之外，还有一些HTTP请求相关的事件，例如：</p><ol><li><p>&#39;checkContinue&#39;：当有HTTP &#39;Expect: 100-continue&#39;请求到达服务器时触发该事件。可以使用<code>server.on(&#39;checkContinue&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数会被传入两个参数：一个request对象和一个response对象。</p></li><li><p>&#39;checkExpectation&#39;：当有HTTP &#39;Expect&#39;请求到达服务器时触发该事件。可以使用<code>server.on(&#39;checkExpectation&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数会被传入两个参数：一个request对象和一个response对象。</p></li><li><p>&#39;clientError&#39;：当客户端发生错误时触发该事件。可以使用<code>server.on(&#39;clientError&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数会被传入一个Error对象，它表示发生的错误。</p></li><li><p>&#39;connect&#39;：当有HTTP &#39;CONNECT&#39;请求到达服务器时触发该事件。可以使用<code>server.on(&#39;connect&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数会被传入两个参数：一个request对象和一个socket对象。</p></li><li><p>&#39;expect&#39;：当有HTTP &#39;Expect&#39;请求到达服务器时触发该事件。可以使用<code>server.on(&#39;expect&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数会被传入两个参数：一个request对象和一个response对象。</p></li><li><p>&#39;request&#39;：当有HTTP请求到达服务器时触发该事件。可以使用<code>server.on(&#39;request&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数会被传入两个参数：一个request对象和一个response对象。</p></li><li><p>&#39;response&#39;：当服务器发送HTTP响应时触发该事件。可以使用<code>server.on(&#39;response&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数会被传入两个参数：一个request对象和一个response对象。</p></li><li><p>&#39;socket&#39;：当一个新的socket对象被分配到一个连接时触发该事件。可以使用<code>server.on(&#39;socket&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数会被传入一个socket对象，它表示一个TCP连接。</p></li><li><p>&#39;timeout&#39;：当服务器超时时触发该事件。可以使用<code>server.on(&#39;timeout&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数不需要传入任何参数。</p></li></ol><p>以上列举的是一些常见的事件类型，还有其他更多的事件类型可以参考官方文档。</p><h3 id="request对象监听器" tabindex="-1"><a class="header-anchor" href="#request对象监听器" aria-hidden="true">#</a> request对象监听器</h3><ol><li><p>&#39;data&#39;：当请求体数据可用时触发该事件。可以使用<code>request.on(&#39;data&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数会被传入一个数据块的Buffer或字符串，一般用chunk表示，表示请求体数据的一部分。</p></li><li><p>&#39;end&#39;：当请求体数据已经被完全接收时触发该事件。可以使用<code>request.on(&#39;end&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数没有参数。</p></li><li><p>&#39;error&#39;：当请求发生错误时触发该事件。可以使用<code>request.on(&#39;error&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数会被传入一个错误对象。</p></li></ol><p>以上是常见的一些可监听的request对象事件，也可以通过自定义事件来实现更多的定制化需求。</p><h3 id="response对象监听器" tabindex="-1"><a class="header-anchor" href="#response对象监听器" aria-hidden="true">#</a> response对象监听器</h3><ol><li><p>&#39;finish&#39;：当所有响应头和响应主体已经被发送时触发该事件。可以使用<code>response.on(&#39;finish&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数没有参数。</p></li><li><p>&#39;close&#39;：当连接关闭时触发该事件。可以使用<code>response.on(&#39;close&#39;, callback)</code>方法来监听该事件。该事件触发时，回调函数没有参数。</p></li></ol><p>以上是常见的一些可监听的response对象事件，也可以通过自定义事件来实现更多的定制化需求。</p>`,16),n=[s];function i(a,d){return r(),c("div",null,n)}const v=e(o,[["render",i],["__file","监听器.html.vue"]]);export{v as default};
